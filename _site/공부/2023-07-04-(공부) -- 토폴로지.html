<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.520">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="신록예찬">
<meta name="dcterms.date" content="2023-07-04">

<title>신록예찬’s Blog - (공부) – 토폴로지</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">신록예찬’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DL2022/"> 
<span class="menu-text">DL2022</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/AP2023/"> 
<span class="menu-text">AP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/PP2023/"> 
<span class="menu-text">PP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DV2022/"> 
<span class="menu-text">DV2022</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/SC2022/"> 
<span class="menu-text">SC2022</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DS2022/"> 
<span class="menu-text">DS2022</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/SP2023/"> 
<span class="menu-text">SP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/IR2021/"> 
<span class="menu-text">IR2021</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://miruetoto.github.io/yechan/"> 
<span class="menu-text">yechan</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://miruetoto.github.io/yechan2/"> 
<span class="menu-text">yechan2</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/miruetoto/yechan3"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">(공부) – 토폴로지</li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../메모.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><strong>메모</strong></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../공부.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><strong>공부</strong></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">연구</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../규빈.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">규빈</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../재인.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">재인</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../서연.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">서연</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../보람.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">보람</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../지윤.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">지윤</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../자료.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><strong>자료</strong></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">(공부) – 토폴로지</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>신록예찬 </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 4, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="about-this-doc" class="level1">
<h1>About this doc</h1>
<p><code>-</code> 수학공부</p>
<p><code>-</code> 학부수준</p>
<p><code>-</code> 이 문서는 논문을 읽을때 등장하는 <strong><em>topology</em></strong> 용어들을 좀더 명확하게 이해하고 싶어서 작성하였다. 가볍게 정의만 훑어보는 것이라 깊게 들어가지는 않을 예정이다. 교재는 Schaum’s General Topology 를 참고하였다. - Lipschutz, S. (1965). Schaum’s outline of theory and problems of general topology. Schaum’s Outline Series.</p>
<p><code>-</code> 여기에서는 토폴로지의 정의와 메트릭스페이스의 정의 그리고 컴플리션의 정의에 대하여 다룬다.</p>
</section>
<section id="chap-5-토폴로지" class="level1">
<h1>Chap 5: 토폴로지</h1>
<p><code>-</code> <strong>(<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, p.66)</strong> <span class="math inline">\({\cal T}\)</span> 가 <span class="math inline">\(X\)</span> 의 subset 으로 이루어진 collection 이라고 하자. <span class="math inline">\({\cal T}\)</span> 가 <span class="math inline">\(X\)</span> 를 포함하며 <strong><em>uncountable union</em></strong> 에 닫혀있고 <strong><em>finite intersection</em></strong> 에 닫혀있다면 <span class="math inline">\({\cal T}\)</span> 를 <span class="math inline">\(X\)</span> 의 topology 라고 한다. 그리고 <span class="math inline">\((X,{\cal T})\)</span> 를 <strong><em>topological space</em></strong> 라고 한다. <span class="math inline">\({\cal T}\)</span> 가 <span class="math inline">\(X\)</span>의 토플로지일때 <span class="math inline">\({\cal T}\)</span> 의 원소를 <strong><em><span class="math inline">\({\cal T}\)</span>-open set</em></strong> 이라고 한다. 따라서 원래 오픈셋은 마치 확률변수처럼 단독으로 정의할 수 없고 어떠한 토폴로지 <span class="math inline">\({\cal T}\)</span>와 같이 정의된다.</p>
<p><code>-</code> <strong>(<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, p.66)</strong> 아래와 같은 collection 을 생각하자.</p>
<p><span class="math display">\[{\cal O}:=\{O: O=\cup_i(a_i,b_i), a_i,b_i \in \mathbb{R} \} \]</span></p>
<p>컬렉션 <span class="math inline">\({\cal O}\)</span> 는 <span class="math inline">\(\mathbb{R}\)</span> 의 토폴로지가 된다. (증명은 알아서..) 이러한 토폴로지(=오픈인터벌의 카운터블-유니온으로 표현가능한 집합들의 모임)을 특별히 <strong><em>usual topology</em></strong> 라고 한다. 그리고 이 토폴로지의 원소를 <span class="math inline">\({\cal O}\)</span>-오픈셋이라고 부른다. 따라서 어떤 집합 <span class="math inline">\(O\)</span> 가 <span class="math inline">\({\cal O}\)</span>-오픈셋 이라는 말은 그 집합이 오픈인터벌의 카운터블-유니온으로 표현가능한 집합임을 의미한다.</p>
<p><code>-</code> 참고로 <span class="math inline">\({\cal O}\)</span> 가 우리가 일반적으로 생각하는 ‘오픈셋들의 모임’ 이고 <span class="math inline">\({\cal O}\)</span>-오픈셋이 보통 우리가 일반적으로 유클리드 공간에서 상상하는 오픈셋이다. <strong>그래서 앞으로 특별한 언급없이 그냥 ‘오픈셋’ 이라고 부르면 토폴로지 <span class="math inline">\((\mathbb{R},{\cal O})\)</span> 에서 정의가능한 ‘<span class="math inline">\({\cal O}\)</span>-오픈셋’ 을 의미하는 것이라고 생각하면 된다.</strong></p>
<p><code>-</code> 즉 우리가 일반적으로 생각하는 오픈셋<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>은 오픈인터벌 <span class="math inline">\((a,b)\)</span> 의 <strong><em>countable-many union</em></strong> 으로 표현가능한 집합이라고 이해해도 된다.</p>
<p><code>-</code> 오픈셋 <span class="math inline">\(O\)</span>의 원소를 <strong><em>interior point of <span class="math inline">\(O\)</span></em></strong> 라고 한다. <span class="math inline">\({\cal O}\)</span>의 정의에 의해서 인테리어포인트는 모두 아래의 성질을 만족한다.</p>
<p><span class="math display">\[\forall o \in O ~ \exists a,b \in \mathbb{R}~ st.~  o \in (a,b)\]</span></p>
<p>증명은 귀류법을 쓰면 쉽게 된다.</p>
<p><code>-</code> 저 정리가 생각보다 중요하다. 그리고 이 정리를 <strong>나이테정리</strong> 라고 기억하자. 이 정리는 <span class="math inline">\({\cal O}\)</span>-오픈셋이 아닌 일반적인 <span class="math inline">\({\cal T}\)</span>-오픈셋에 대하여서도 성립한다. 즉 <span class="math inline">\((X,{\cal T})\)</span>가 위상공간이고 <span class="math inline">\(T\)</span>가 <span class="math inline">\({\cal T}\)</span>의 임의의 집합이라 하자. <span class="math inline">\(T\)</span>의 임의의 원소 <span class="math inline">\(p\)</span>에 대하여 (1) <span class="math inline">\(p\)</span> 를 포함하지만 (2) <span class="math inline">\(T\)</span> 보다 작은 다른 <span class="math inline">\({\cal T}\)</span>-오픈셋이 항상 존재한다.</p>
<p><code>-</code> 그리고 교재에 따라서는 위와 같은 성질을 만족하는 것을 오픈셋이라고 정의하기도 한다. 이와 같은 논리흐름으로는 오픈인터벌 <span class="math inline">\((a,b)\)</span>를 정의하고 그로부터 인테리어포인트 <span class="math inline">\(o\)</span>와 오픈셋 <span class="math inline">\(O\)</span>를 정의하고 그로부터 토폴로지 <span class="math inline">\({\cal O}\)</span>를 정의할 수 있다. 하지만 이러한 방식의 <strong><em>contruction</em></strong> 으로는 <span class="math inline">\((\mathbb{R},{\cal O})\)</span> 만 만들수있다. 일반적으로는 적당한 <span class="math inline">\({\cal T}\)</span>가 <span class="math inline">\(X\)</span>의 토폴로지임을 밝히고 그로부터 오픈셋을 정의하고 그 다음 인테리어포인트를 정의하는 식으로 각 요소들을 contruction 한다.</p>
<p><code>-</code> 오픈셋의 여집합을 클로즈드셋이라고 한다. 여기서 사람들이 “모든 집합은 오픈셋이거나 클로즈드셋 이어야 한다” 라고 착각하기 쉬운데 사실 그런것은 아니다.</p>
<p><code>-</code> 어떠한 construction을 사용하든지 아래의 사실들이 성립한다. 따로 설명을 쓰지 않은 것은 아주 약간의 머리를 쓰면 쉽게 증명할 수 있는 것들이다. (하지만 그냥 받아들이거나 외우는 것이 편하다.) 참고로 아래의 모든 사실들은 보통위상공간 즉 <span class="math inline">\((\mathbb{R},{\cal O})\)</span> 를 전제하고 서술한 것이다.</p>
<p><strong>(1)</strong> <span class="math inline">\((a,b)\)</span> 는 오픈셋이다.</p>
<p><strong>(2)</strong> <span class="math inline">\(\mathbb{R}\)</span> 은 오픈셋이다. 동시에 클로즈드셋이다<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p><strong>(3)</strong> <span class="math inline">\(\emptyset\)</span> 은 오픈셋이다. 동시에 클로즈드셋이다<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p><strong>(4)</strong> 오픈셋은 <strong><em>uncountable union</em></strong> 에 닫혀있다. 즉 <span class="math inline">\(O_t\)</span>가 각각 오픈셋일때 <span class="math inline">\(\cup_t O_t\)</span> 역시 오픈셋이다.</p>
<p><strong>(5)</strong> 오픈셋은 <strong><em>finite intersection</em></strong> 에 닫혀있다. 즉 <span class="math inline">\(O_i\)</span>가 각각 오픈셋이면 <span class="math inline">\(\cap_{i=1}^{n} O_i\)</span> 역시 오픈셋이다</p>
<p><strong>(6)</strong> 한점 <span class="math inline">\(p\)</span>로 이루어진 집합 <span class="math inline">\(\{p\}\)</span>는 오픈셋이 아니다. 이것이 오픈셋이 되려면 <span class="math inline">\(\{p\}\)</span>의 모든원소(라고 해봤자 <span class="math inline">\(p\)</span> 밖에 없음)가 내점이어야 하고 <span class="math inline">\(p\)</span>가 <span class="math inline">\(\{p\}\)</span>의 내점이려면 <span class="math inline">\(p\)</span>를 포함하는 오픈인터벌 <span class="math inline">\((a,b)\)</span>가 <span class="math inline">\(\{p\}\)</span>의 부분집합으로 존재해야하는데 이것이 불가능하기 때문이다. <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p><strong>(7)</strong> 오픈셋의 <strong><em>countable-many intersection</em></strong> 은 오픈셋이 아니다. 왜냐하면 <span class="math inline">\(\cap_{n=1}^{\infty}(-1/n,1/n)=\{0\}\)</span> 인데 <span class="math inline">\(\{0\}\)</span>은 오픈셋이 아니기 때문이다.</p>
<p><code>-</code> (<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, p.&nbsp;69) 위상공간 <span class="math inline">\((X,{\cal T})\)</span> 를 상상하자. <span class="math inline">\(X\)</span>의 부분집합 <span class="math inline">\(A\)</span>를 상상하자. <strong><em>“집합 <span class="math inline">\(A\)</span>가 <span class="math inline">\(X\)</span>에서 dense 하다”</em></strong> 라는 의미는 <span class="math inline">\(\bar{A}=X\)</span>라는 의미이다. 가장 빈번하게 사용하는 표현은 “유리수집합 <span class="math inline">\(\mathbb{Q}\)</span>는 실수 <span class="math inline">\(\mathbb{R}\)</span>에서 dense 하다” 인데 이것은<span class="math inline">\(\bar{\mathbb{Q}}=\mathbb{R}\)</span>이 성립하기 때문이다 (예제 4.3).</p>
</section>
<section id="chap-6-기저" class="level1">
<h1>Chap 6: 기저</h1>
<p><code>-</code> 오픈인터벌 <span class="math inline">\((a,b)\)</span>를 적당히 countable-many union 하면 <span class="math inline">\(\mathbb{R}\)</span> 에 존재하는 어떠한 오픈셋 <span class="math inline">\(O\)</span>도 표현할 수 있다. 이럴때 <span class="math inline">\((a,b)\)</span> 모아놓은 collection <span class="math inline">\({\cal B}:=\{(a,b): a&lt;b \in \mathbb{R}\}\)</span> 를 토폴로지 <span class="math inline">\({\cal O}\)</span>의 <strong><em>base</em></strong> 라고 한다. 이처럼 어떠한 위상공간 <span class="math inline">\((X,{\cal T})\)</span> 가 있을때 토폴로지 <span class="math inline">\({\cal T}\)</span> 의 임의의 집합을 <span class="math inline">\({\cal B}\)</span>의 원소들의 uncountable union 으로 표현가능때 <span class="math inline">\({\cal B}\)</span>를 <span class="math inline">\({\cal T}\)</span>의 <strong><em>base</em></strong> 라고 한다. 그리고 추가적으로 base의 모든 원소는 <span class="math inline">\({\cal T}\)</span>-오픈셋이어야 한다는 조건도 포함된다.</p>
<p><code>-</code> 토폴로지 <span class="math inline">\({\cal T}\)</span>의 base는 유일하지 않다.</p>
<p><code>-</code> 아래와 같은 collection을 상상하여 보자.</p>
<p><span class="math display">\[\tilde{\cal B}:=\{all~ ray~ in~\mathbb{R} \} := \{(-\infty,b): b\in \mathbb{R} \} \cup \{(a,\infty): a \in \mathbb{R}\}\]</span></p>
<p>보는 것처럼 <span class="math inline">\(\tilde{\cal B}\)</span>는 위상의 정의를 만족한다. 그리고 <span class="math inline">\(\tilde{\cal B}\)</span>는 <span class="math inline">\({\cal O}\)</span>의 base가 아니다. 하지만 <span class="math inline">\(\pi(\tilde{\cal B})\)</span> 는 <span class="math inline">\((a,b)\)</span>를 포함하고 있기에 <span class="math inline">\({\cal O}\)</span> 의 base가 된다. 여기에서 <span class="math inline">\(\pi(\tilde{\cal B})\)</span> 는 <span class="math inline">\(\tilde{\cal B}\)</span> 에 의해서 생성된 가장 작은 <strong><em><span class="math inline">\(\pi\)</span>-system</em></strong> 이다.</p>
<p><code>-</code> 참고로 <span class="math inline">\(\pi\)</span>-시스템은 모든 원소가 <strong><em>finite intersection</em></strong> 에 닫혀있는 collection 을 의미한다. 전체집합은 <strong><em>empty intersection</em></strong> 으로 해석할 수 있으므로 모든 파이시스템은 전체집합을 포함한다. 따라서 파이시스템을 정의하면 전체집합을 같이 정의하는것과 마찬가지이다. 따라서 파이시스템 역시 시그마필드와 토폴로지처럼 전체집합과 동시에 정의된다. 그리고 정의에 따라서 임의의 집합에 대한 토폴로지와 시그마필드 모두 파이시스템이 된다.</p>
<p><code>-</code> 위에서 예를 든 <span class="math inline">\(\tilde{\cal B}\)</span> 와 같이 그것 자체가 어떤 위상 <span class="math inline">\({\cal T}\)</span> 의 base는 아니지만 <span class="math inline">\(\pi(\tilde{\cal B})\)</span> 는 <span class="math inline">\({\cal T}\)</span> 의 base가 될때 <span class="math inline">\(\tilde{\cal B}\)</span>를 <span class="math inline">\({\cal T}\)</span>의 <strong><em>subbase</em></strong> 라고 한다.</p>
<p><code>-</code> <span class="math inline">\(\tilde{\cal B}\)</span> 가 토폴로지 <span class="math inline">\({\cal T}\)</span>의 subbase이면 <span class="math inline">\(\tilde{\cal B}\)</span>로 <span class="math inline">\({\cal T}\)</span>를 <strong><em>generate</em></strong> 할 수 있다.</p>
</section>
<section id="chap-8-metric-and-normed-spaces" class="level1">
<h1>Chap 8: Metric and Normed Spaces</h1>
<p><code>-</code> <span class="math inline">\(d:X \times X \to \mathbb{R}\)</span> 가 (1) 음이 아니고 (2) 대칭이며 (3) 삼각부등식을 만족하면 집합 <span class="math inline">\(X\)</span> 에서의 <strong><em>metric</em></strong> 이라고 한다. 이때 음이 아닐 조건은</p>
<p><span class="math display">\[\begin{cases}
d(a,b) &gt; 0 &amp; a \neq b \\
d(a,b) = 0 &amp; a=b
\end{cases}\]</span></p>
<p>이다. 만약에 메트릭의 모든 조건을 만족하는데 <span class="math inline">\(d(a,b)=0\)</span> 인 서로 다른 <span class="math inline">\(a,b \in X\)</span> 가 존재하는 경우 <span class="math inline">\(d\)</span> 를 <strong><em>pseudometric</em></strong> 이라고 한다.</p>
<p><code>-</code> <span class="math inline">\(d\)</span> 을 집합 <span class="math inline">\(X\)</span> 에서의 메트릭이라고 하자. 메트릭이 존재한다는 것은 집합 <span class="math inline">\(X\)</span>의 어떠한 두 원소라도 그 사이의 거리를 잴 수 있다는 말이고 그것은 집합 <span class="math inline">\(X\)</span>의 임의의 점 <span class="math inline">\(p\)</span>에서 아래와 같은 <strong><em>ball</em></strong> 을 정의할 수 있는 말이다.</p>
<p><span class="math display">\[S(p,\delta) := \{x:d(p,x)&lt;\delta,x \in X \}\]</span></p>
<p>참고로 위와 같은 ball 들을 모은 collection 을 <span class="math inline">\({\cal B}\)</span>라고 하자. 그리고 <span class="math inline">\({\cal B}\)</span>의 임의의 원소를 언카운터블-유니온하여 얻을 수 있는 집합들의 모임을 <span class="math inline">\({\cal T}\)</span>라고 하자. 그러면 (1) <span class="math inline">\({\cal T}\)</span> 가 <span class="math inline">\(X\)</span> 의 토폴로지임을 보이고 (2) <span class="math inline">\({\cal B}\)</span>의 모든 원소가 <span class="math inline">\({\cal T}\)</span>-오픈셋임을 보인다면 <span class="math inline">\({\cal B}\)</span>는 <span class="math inline">\({\cal T}\)</span>의 base가 된다고 주장할 수 있다(<strong><em>Thm 8.4</em></strong>). 그런데 (2)는 (1)이 성립하면 자동으로 성립하므로 (1)만 보이면 된다. 그러기 위해서는 아래의 (i)-(iii)을 보이면 된다.</p>
<p><strong><em>(i)</em></strong> 우선 <span class="math inline">\({\cal T}\)</span>가 언카운터블-유니온에 닫혀있음은 <strong><em>associative laws</em></strong> 에 의해서 쉽게 증명된다.</p>
<p><strong><em>(ii)</em></strong> 이제 <span class="math inline">\({\cal T}\)</span>가 파이나이트-인터섹션에 닫혀있음을 보이자. <span class="math inline">\({\cal T}\)</span>의 임의의 두 원소는 각각 <span class="math inline">\({\cal B}\)</span>의 언카운터블-유니온으로 표현가능하다. 가령 예를들어 임의의 <span class="math inline">\(T,S \in {\cal T}\)</span> 가 아래와 같이 표현되었다고 치자.</p>
<p><span class="math display">\[T=\bigcup_{t\in [0,1]}B_{t}, \quad S=\bigcup_{s\in [2,3]}B_{s}\]</span></p>
<p>따라서 <span class="math inline">\(T\cap S\)</span> 는 <strong><em>distributive laws</em></strong> 에 의해서 아래와 같이 표현가능하다.</p>
<p><span class="math display">\[T \cap S = \bigcup_{(t,s) \in [0,1]\times[2,3]} B_t \cap B_s \]</span></p>
<p>(i)에 의해서 <span class="math inline">\(B_t \cap B_s\)</span>가 <span class="math inline">\({\cal T}\)</span>의 원소이기만 하면 <span class="math inline">\(T \cap S\)</span> 역시 <span class="math inline">\({\cal T}\)</span>의 원소가 되는 구조라 (ii)가 증명된다. 따라서 이제 우리가 할일은 <span class="math inline">\(B_t\cap B_s\)</span>가 <span class="math inline">\({\cal T}\)</span>의 원소임을 보이는 것이고 이것은 <span class="math inline">\(B_t \cap B_s\)</span>가 <span class="math inline">\({\cal B}\)</span>의 언카운터블-유니온으로 표현가능하다는 조건과 동치이다. 우선 <span class="math inline">\(B_t \cap B_s\)</span>에 속하는 임의의 원소를 $b^* $ 라고 하자. 이 점에 대하여 <strong>나이테정리</strong>를 만족시키는 ball이 존재한다. 즉</p>
<p><span class="math display">\[\exists S(b^* ,\delta)~ st. ~ S(b^* ,\delta) \subset B_t \cap B_s\]</span></p>
<p>이다(<strong><em>Lemma 8.3</em></strong>). 그런데 <span class="math inline">\(B_t \cap B_s\)</span>의 모든점에서 이런식으로 나이테정리를 만족하는 ball을 잡을 수 있다. 이러한 ball들의 합집합을</p>
<p><span class="math display">\[\bigcup_{b^* \in (B_t \cap B_s)} S(b^* , \delta)\]</span></p>
<p>이라고 하자. 자명하게 이 집합은 <span class="math inline">\(B_t\cap B_s\)</span> 보다 작다(부분집합들의 합이므로). 하지만 <span class="math inline">\(B_t\cap B_s\)</span>의 모든 원소는 이 집합에 포함되므로 이 집합은 <span class="math inline">\(B_t\cap B_s\)</span>보다 크다. 따라서</p>
<p><span class="math display">\[\bigcup_{b^* \in (B_t \cap B_s)} S(b^* , \delta)=B_t \cap B_s\]</span></p>
<p>이 성립한다.</p>
<p><strong><em>(iii)</em></strong> <span class="math inline">\({\cal T}\)</span>가 <span class="math inline">\(X\)</span>를 포함한다는 것을 보이는것은 볼의 반지름을 크게 만들면 쉽게 증명할 수 있다.</p>
<p><code>-</code> 참고로 위의 (i)-(iii)을 요약하면 (1) <span class="math inline">\(X\)</span>가 <span class="math inline">\({\cal B}\)</span>의 언카운터블 유니온으로 표현가능하고 (2) <span class="math inline">\({\cal B}\)</span>의 임의의 두 원소가 <span class="math inline">\({\cal B}\)</span>의 언카운터블 유니온으로 표현가능하기만 하면 볼들이 집합이 아니라 어떠한 <span class="math inline">\({\cal B}\)</span>라도 특정 토폴로지의 base라고 주장할 수 있다. 이것이 교재의 <strong><em>Thm 6.1</em></strong> 이다.</p>
<p><code>-</code> 아무튼 위의 과정을 거치면 <span class="math inline">\(X\)</span>위에서 거리를 정의할 수 있을때 그 거리에 의해서 ball을 정의할 수 있고 ball들의 콜렉션을 base <span class="math inline">\({\cal B}\)</span>로 정의하고 <span class="math inline">\({\cal B}\)</span> 원소들의 언카운터블-유니온으로 표현가능한 집합모임을 토폴로지 <span class="math inline">\({\cal T}\)</span>로 정의해도 논리적모순점이 없다. 즉 <span class="math inline">\(X\)</span>에서 메트릭이 정의되기만 하면 그것에 의해서 순차적으로 토폴로지 <span class="math inline">\({\cal T}\)</span>를 자연스럽게 유도할 수 있는데 이러한 토폴로지를 특별히 <span class="math inline">\(X\)</span>와 <span class="math inline">\(d\)</span>에 의해서 유도된 <strong><em>metric topology</em></strong> 라고 한다. 그리고 <span class="math inline">\((X,d)\)</span>를 <strong><em>metric-space</em></strong> 라고 한다.</p>
<p><code>-</code> <span class="math inline">\(\mathbb{R}\)</span>에서 <span class="math inline">\({\cal O}\)</span>를 유도하는 메트릭은 우리가 보통 생각하는 유클리드거리이다. 이러한 메트릭을 <strong><em>usual metric</em></strong> 이라고 한다.</p>
<p><code>-</code> <span class="math inline">\(\mathbb{R}\)</span>에서 아래와 같은 거리를 정의할 수 있다.</p>
<p><span class="math display">\[d(a,b)=\begin{cases}
0 &amp; a=b \\
1 &amp; a\neq b
\end{cases}\]</span></p>
<p>이러한 거리를 <strong><em>trivial metric</em></strong> 이라고 한다. 그리고 이 거리가 유도하는 토폴로지는 <span class="math inline">\(2^{\mathbb{R}}\)</span> 이다. (아 몰라.. 따지기 싫어.. 그냥 외워..)</p>
<p><code>-</code> 만약에 집합 <span class="math inline">\(X\)</span>에서 정의된 2개의 메트릭 <span class="math inline">\(d_1\)</span>, <span class="math inline">\(d_2\)</span>가 같은 토폴로지를 유도한다면 두 메트릭 <span class="math inline">\(d_1\)</span>과 <span class="math inline">\(d_2\)</span>는 <strong><em>equivalent</em></strong> 하다고 말한다.</p>
<p><code>-</code> 토폴로지컬-스페이스 <span class="math inline">\((X,{\cal T})\)</span> 가 있다고 하자. 그런데 <span class="math inline">\(X\)</span> 에서 어떠한 메트릭 <span class="math inline">\(d\)</span>가 존재해 그것이 <span class="math inline">\({\cal T}\)</span>를 유도하였다고 하자. 그럼 <span class="math inline">\({\cal T}\)</span>는 메트릭-토폴로지가 된다. 이와 같이 (1) <span class="math inline">\(X\)</span>에서 정의되고 (2) 메트릭-토폴로지 <span class="math inline">\({\cal T}\)</span>를 유도하는 적당한 메트릭 <span class="math inline">\(d\)</span>가 명시된것은 아니지만 그런 메트릭의 존재를 하나 이상 우리가 알고 있을때 위상공간 <span class="math inline">\((X,{\cal T})\)</span>를 <strong><em>metrizable</em></strong> 하다고 한다.</p>
<p><code>-</code> 두 메트릭스페이스 <span class="math inline">\((X,d_1)\)</span> 와 <span class="math inline">\((Y,d_2)\)</span> 가 <strong><em>isometric</em></strong> 하다는 것은 아래가 만족하는 <strong><em>one-one, onto</em></strong> 인 <span class="math inline">\(f:X \to Y\)</span> 가 존재한다는 것이다.</p>
<p><span class="math display">\[d_1(p,q) = d_2(f(p),f(q))\]</span></p>
<p><code>-</code> 이때 isometric 이라는 <strong><em>relation</em></strong> 은 보는것 처럼 모든 메트릭공간들의 집합 <span class="math inline">\({\cal M}\)</span>에서 <strong><em>equivalence relation</em></strong> 이다. 즉 아래가 성립한다.</p>
<p><strong>(i)</strong> <span class="math inline">\((X,d_1) \overset{ism}{\sim} (X,d_1)\)</span>,</p>
<p><strong>(ii)</strong> <span class="math inline">\((X,d_1) \overset{ism}{\sim} (Y,d_2)\)</span> implies <span class="math inline">\((Y,d_2) \overset{ism}{\sim} (X,d_1)\)</span>,</p>
<p><strong>(iii)</strong> <span class="math inline">\((X,d_1) \overset{ism}{\sim} (Y,d_2)\)</span> and <span class="math inline">\((Y,d_2) \overset{ism}{\sim} (Z,d_3)\)</span> imply <span class="math inline">\((X,d_1) \overset{ism}{\sim} (Z,d_3)\)</span>.</p>
</section>
<section id="chap-9-countability" class="level1">
<h1>Chap 9: Countability</h1>
<p><code>-</code> (<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, p.&nbsp;132) 위상공간 <span class="math inline">\((X,{\cal T})\)</span>가 <strong><em>separable</em></strong> 하다는 의미는 <span class="math inline">\((X,{\cal T})\)</span> countable dense subset 을 가진다는 의미이다.</p>
<p><code>-</code> 위상공간 <span class="math inline">\((\mathbb{R}, {\cal O})\)</span>를 상상하자.</p>
<ul>
<li><span class="math inline">\(A_n = [-n,n] \cap \mathbb{Q}\)</span></li>
</ul>
<p>라고 한다면 (1) <span class="math inline">\({\cal A} = \{A_n\}\)</span> 은 countable 하고 (2) <span class="math inline">\(A_n\)</span>은 모두 (<span class="math inline">\([-n,n]\)</span>에서) dense 하다. 따라서 <span class="math inline">\(\mathbb{R}\)</span>은 countable한 dense subset을 가진다. 따라서 <span class="math inline">\((\mathbb{R},{\cal O})\)</span>는 seperable 하다.</p>
</section>
<section id="chap-10-separation-axioms" class="level1">
<h1>Chap 10: Separation Axioms</h1>
<p><code>-</code> 예비학습1: 위상공간 <span class="math inline">\((X,{\cal T})\)</span>를 고려하자. <span class="math inline">\(X\)</span>의 임의의 닫힌집합 <span class="math inline">\(F\)</span>를 상상하자. 그리고 <span class="math inline">\(F\)</span>에 소속되지 않은 한 점 <span class="math inline">\(p \in X\)</span>를 상상하자. 이제 닫힌집합 <span class="math inline">\(F\)</span>를 포함하는 아주 작은 열린집합 <span class="math inline">\(G\)</span>와 <span class="math inline">\(p\)</span>를 포함하는 아주 작은 열린집합 <span class="math inline">\(H\)</span>를 상상하자. 위상공간 <span class="math inline">\((X,{\cal T})\)</span>에서 임의의 <span class="math inline">\(F\)</span>와 <span class="math inline">\(p\)</span>에 대하여서도 두 열린집합 <span class="math inline">\(G\)</span>,<span class="math inline">\(H\)</span>가 서로소가 되도록 선택할 수 있다면 그 위상공간은 <strong><em>regular</em></strong> 하다고 표현한다 (<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, p.&nbsp;140).</p>
<p><strong><em>이해를 위한 예시</em></strong></p>
<ul>
<li><span class="math inline">\(F= [0,1]\)</span></li>
<li><span class="math inline">\(p = 1.01\)</span></li>
<li><span class="math inline">\(G= (-0.001, 1.001)\)</span></li>
<li><span class="math inline">\(H= (1.009,1.011)\)</span></li>
</ul>
<p><code>-</code> 예비학습2: 위상공간 <span class="math inline">\((X,{\cal T})\)</span>를 고려하자. <span class="math inline">\(X\)</span>의 부분집합중 서로소인 닫힌집합 <span class="math inline">\(F_1,F_2\)</span>를 상상하자.이제 닫힌집합 <span class="math inline">\(F_1\)</span>를 포함하는 아주 작은 열린집합 <span class="math inline">\(G\)</span>와 <span class="math inline">\(F_2\)</span>를 포함하는 아주 작은 열린집합 <span class="math inline">\(H\)</span>를 상상하자. 위상공간 <span class="math inline">\((X,{\cal T})\)</span>에서 임의의 <span class="math inline">\(F_1\)</span>와 <span class="math inline">\(F_2\)</span>에 대하여서도 두 열린집합 <span class="math inline">\(G\)</span>,<span class="math inline">\(H\)</span>가 서로소가 되도록 선택할 수 있다면 그 위상공간은 <strong><em>normal</em></strong> 하다고 표현한다 (<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, p.&nbsp;141).</p>
<p><code>-</code> 위상공간 <span class="math inline">\((X,{\cal T})\)</span> 에는 얼마나 많은 (혹은 다양한) 열린집합이 있을까? 위상공간 <span class="math inline">\((X,{\cal T}_1)\)</span>이 <span class="math inline">\(T_1\)</span>-space라는 의미는 서로 다른 <span class="math inline">\(a,b \in X\)</span>에 대하여 <span class="math inline">\(a\)</span>만 포함하는 열린집합 혹은 <span class="math inline">\(b\)</span>만 포함하는 열린집합이 각각 존재한다는 의미이다.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> 위상공간 <span class="math inline">\((X,{\cal T}_2)\)</span>이 <span class="math inline">\(T_2\)</span>-space 혹은 Hausdorff space라는 의미는 <span class="math inline">\(T_1\)</span>-space에서, <span class="math inline">\(a\)</span>만 포함하는 열린집합과 <span class="math inline">\(b\)</span>만 포함하는 열린집합이 서로 disjoint한 경우를 의미한다. 위상공간 <span class="math inline">\((X,{\cal T}_3)\)</span>이 <span class="math inline">\(T_3\)</span>-space 라는 의미는 <span class="math inline">\(T_1\)</span>이고 <strong><em>regular space</em></strong> 라는 의미이다. 위상공간 <span class="math inline">\((X,{\cal T}_4)\)</span>이 <span class="math inline">\(T_4\)</span>-space 라는 의미는 <span class="math inline">\(T_1\)</span>이고 <strong><em>normal space</em></strong> 라는 의미이다.</p>
<p><code>-</code> 포함관계: <span class="math inline">\(T_1\)</span>-space는 <span class="math inline">\(T_2\)</span>-space를 포함하고, <span class="math inline">\(T_2\)</span>-space는 <span class="math inline">\(T_3\)</span>-space를, <span class="math inline">\(T_3\)</span>-space는 <span class="math inline">\(T_4\)</span>-space를 포함한다 (<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, p.&nbsp;141 그림). 그리고 metric space는 <span class="math inline">\(T_4\)</span> space에 포함된다.</p>
<p><code>-</code> <span class="math inline">\(T_1\)</span> 위상공간에서는 “singleton = closed set” 이라고 주장할 수 있다. (<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, Thm 10.1) <span class="math inline">\(T_2\)</span> 위상공간에서는 “convergent sequence has a unique limit” 을 주장할 수 있다 (<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, Thm 10.3). <span class="math inline">\(T_3\)</span> 위상공간은 특별히 기억할만한 부분이 없어보인다. <span class="math inline">\(T_4\)</span> 위상공간은 우리손레마 (urysohn lemma) 가 성립하는 공간이다 (<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, Thm 10.7).</p>
<p><code>-</code> <strong>우리손레마</strong>: <span class="math inline">\(T_4\)</span> 위상공간 <span class="math inline">\((X,{\cal T}_4)\)</span>를 상상하자. 그리고 <span class="math inline">\(X\)</span>의 부분집합 중 서로소인 닫힌 부분집합 <span class="math inline">\(F_1,F_2\)</span>를 상상하자. 우리손레마에 의하면 어떠한 <span class="math inline">\(F_1,F_2\)</span>에 대하여서도,</p>
<ul>
<li><span class="math inline">\(f(F_1)=\{0\}\)</span></li>
<li><span class="math inline">\(f(F_1)=\{1\}\)</span></li>
</ul>
<p>를 만족하는 적당한 연속함수 <span class="math inline">\(f:X \to [0,1]\)</span>이 항상 존재함이 알려져 있다 (<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, Thm 10.7). 이것은 <span class="math inline">\(F_1,F_2\)</span>를 구분할 수 있는 어떠한 함수 <span class="math inline">\(f\)</span>가 항상 존재함을 의미하는데 이는 <span class="math inline">\((X,{\cal T}_4)\)</span>를 거리공간화 하는데 이용할 수 있다. 구체적으로 위상공간 <span class="math inline">\((X,{\cal T}_4)\)</span>가 추가적으로 <strong><em>second coutable</em></strong> 조건을 만족한다면<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> <span class="math inline">\((X,{\cal T}_4)\)</span> 는 거리공간으로 바꿀 수 있음이 알려져 있다 (<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, Thm 10.8).</p>
<p><code>-</code> 위상공간 <span class="math inline">\((X,{\cal T})\)</span>가 <span class="math inline">\(T_4\)</span>-space이고 추가적으로 <strong><em>second coutable space</em></strong> 라면 <span class="math inline">\((X,{\cal T})\)</span>는 Hilbert cube 와 호모몰픽(homeomorphic) 하다는 것이 알려져 있다 (<span class="citation" data-cites="lipschutz1965schaum">@lipschutz1965schaum</span>, p.&nbsp;142).</p>
</section>
<section id="chap-14-complete-metric-spaces" class="level1">
<h1>Chap 14: Complete Metric Spaces</h1>
<p><code>-</code> <strong><em>Convergent sequence</em></strong> 은 단독으로 정의될 수 없으며 위상공간 <span class="math inline">\((X,{\cal T})\)</span> 와 묶어서 정의된다. 그리고 <strong><em>Cauchy sequence</em></strong> 역시 단독으로 정의될 수 없으며 메트릭스페이스 <span class="math inline">\((X,d)\)</span> 와 묶어서 정의된다.</p>
<p><code>-</code> <strong><em>Convergent sequence</em></strong> 와 <strong><em>Cauchy sequence</em></strong> 는 비슷해보이지만 미묘하게 다른점이 있다.</p>
<p><strong>(1)</strong> 컨버전트-시컨트는 위상공간 <span class="math inline">\((X,{\cal T})\)</span> 만 있으면 정의할 수 있지만 코시수열은 그 위상공간이 메트릭스페이스 이어야 한다는 제약이 있다. 왜냐하면 컨버전트-시컨스의 정의에는 오픈셋만 필요하지만 코시수열은 볼이 필요하고 볼은 메트릭에 의해서만 정의되기 때문이다.</p>
<p><strong>(2)</strong> 컨버전트-시컨스와 코시수열 모두 열의 각 항이 <span class="math inline">\(X\)</span>의 원소이어야 한다는 조건이 있다. 하지만 컨버전트-시컨스는 그 <strong><em>limit</em></strong> 까지 <span class="math inline">\(X\)</span>의 원소이어야 하는데 코시수열은 그렇지 않다는 차이점이 있다.</p>
<p><code>-</code> <span class="math inline">\(X=(0,1)\)</span> 위의 usual metric 에 의해서 유도되는 메트릭스페이스 <span class="math inline">\((X,d)\)</span> 를 생각하자. 수열</p>
<p><span class="math display">\[\left\{\frac{1}{2},\frac{1}{3},\frac{1}{4},\dots,\right\}\]</span></p>
<p><span class="math inline">\(X\)</span>에서 정의된 코시수열이지만 <span class="math inline">\(X\)</span>에서 정의되는 컨버전트-시컨스는 아니다.</p>
<p><code>-</code> 내가 이해한 바는 아래와 같다.</p>
<p><strong>(1)</strong> 토폴로지 <span class="math inline">\((X,{\cal T})\)</span> 는 항상 컨버전트-시컨스를 정의할 준비가 되어있는 공간이다.</p>
<p><strong>(2)</strong> 위에서 정의가능한 컨버전트-시컨스는 코시수열과 아무런 관련이 없다. 그리고 우리가 통상적으로 고등학교때부터 다루어왔던 수열의 수렴의 개념과도 거리가 멀다.</p>
<p><strong>(3)</strong> 토폴로지 <span class="math inline">\((X,{\cal T})\)</span> 가 메트릭스페이스라면 컨버전트-시컨스는 코시수열과 어떤관계가 있으며 고등학교때부터 내가 다루어 왔던 상식적인 수렴하는 수열의 개념과도 관련이 있다.</p>
<p><strong>(4)</strong> <span class="math inline">\((X,{\cal T})\)</span> 가 메트릭스페이스 라고 가정하자. 그럼 아래가 만족한다고 생각할 수 있다.</p>
<blockquote class="blockquote">
<p><span class="math inline">\(\{a_n\}\)</span> converges on <span class="math inline">\(X\)</span> <span class="math inline">\(\Longleftrightarrow\)</span> <span class="math inline">\(\{a_b\}\)</span> is Cauchy sequence on <span class="math inline">\(X\)</span> and <span class="math inline">\(\lim_{n\to\infty} a_n \in X\)</span></p>
</blockquote>
<p>즉 러프하게 말해서 <span class="math inline">\(X\)</span>에서의 컨버전트-시컨스는 (i) <span class="math inline">\(X\)</span>에서의 코시수열이면서 (ii) <strong><em>limit</em></strong> 이 <span class="math inline">\(X\)</span>에 포함되는 수열이라고 말할 수 있다. 이런 정의로 치면 우리가 고등학교때부터 생각해왔던 소박한 정의의 수렴하는 수열은 사실 코시수열에 가깝고 컨버전트-시컨스는 고등학교때부터 배운 소박한 수렴을 하며 동시에 수렴값이 <span class="math inline">\(X\)</span>에서 잘 정의되는 수열을 의미한다고 볼 수 있다. 앞으로는 소박한 수렴과 컨버전트-시컨스를 엄밀하게 구분하여 말하도록 하자. 즉 <span class="math inline">\(\{a_n\}\)</span>이 코시수열이라는 말은 <span class="math inline">\(\{a_n\}\)</span>이 소박한 수렴을 한다는 의미이고 <span class="math inline">\(\{a_n\}\)</span>이 컨버전트-시컨스라는 의미는 <span class="math inline">\(\{a_n\}\)</span>이 소박한수렴을 하며 동시에 그 극한값이 <strong><em>well-define</em></strong> 된다는 의미(=<span class="math inline">\(\{a_n\}\)</span>의 수렴값이 <span class="math inline">\(X\)</span>의 원소라는 의미)이다.</p>
<p><code>-</code> <strong><em>(proposition 14.1)</em></strong> 메트릭스페이스 한정으로, 컨버전트-시컨스는 모두 코시수열이다. (당연한 소리를.. 이런걸 proposition 이라고..)</p>
<p><code>-</code> 당연히 위 정리의 역은 성립하지 않는다. 즉 메트릭스페이스 <span class="math inline">\((X,{\cal T})\)</span> 에서 정의된 코시수열이 반드시 컨버전트-시컨스라는 보장은 없다. (이것도 당연한 소리.. 왜냐하면 수렴값이 <span class="math inline">\(X\)</span>에 포함된다는 보장이 없기 때문) 하지만 그 메트릭스페이스가 <strong><em>complete</em></strong> 하다면 위 정리의 역도 성립한다.</p>
<p><code>-</code> 컴플리트하지 않은 메트릭스페이스 <span class="math inline">\((X,d)\)</span>를 컴플리트한 메트릭스페이스 <span class="math inline">\((X^* , d)\)</span> 로 바꿀 수 없을까? 유주얼메트릭(usual metric) <span class="math inline">\(d\)</span> 와 <span class="math inline">\(X=(0,1)\)</span> 로 만들어지는 메트릭스페이스는 컴플리트하지 않지만 <span class="math inline">\(d\)</span> 와 <span class="math inline">\(X^* =[0,1]\)</span> 로 만들어지는 메트릭스페이스는 컴플리트하다. 이런 경우 $(X^* ,d) $ 는 <span class="math inline">\((X,d)\)</span> 의 <strong><em>completion</em></strong> 이라고 한다.</p>
<p><code>-</code> 즉 아래의 조건들을 만족하면 공간 $(X^* ,d) $ 는 공간 <span class="math inline">\((X,d)\)</span> 의 <strong><em>completion</em></strong> 이라고 부른다.</p>
<p><strong>(1)</strong> <span class="math inline">\(X\subset X^*\)</span></p>
<p><strong>(2)</strong> <span class="math inline">\((X^* ,d)\)</span> is complete metric space</p>
<p><strong>(3)</strong> <span class="math inline">\((X,d) \overset{ism}{\sim} (X^* ,d)\)</span>.</p>
<section id="메트릭스페이스-xd에서-아래의-식을-만족하는-두-코시수열-a_n-tilde-a_n-을-생각하여보자." class="level5">
<h5 class="anchored" data-anchor-id="메트릭스페이스-xd에서-아래의-식을-만족하는-두-코시수열-a_n-tilde-a_n-을-생각하여보자."><code>-</code> 메트릭스페이스 <span class="math inline">\((X,d)\)</span>에서 아래의 식을 만족하는 두 코시수열 <span class="math inline">\(\{a_n\}\)</span>, <span class="math inline">\(\{\tilde a_n\}\)</span> 을 생각하여보자.</h5>
<p><span class="math display">\[\lim_{n\to\infty} d(a_n,\tilde a_n)=0 \]</span></p>
<p>이러한 코시수열들을</p>
<p><span class="math display">\[\{a_n\} \overset{slim}{\sim} \{\tilde a_n\}\]</span></p>
<p>이라고 표현하자. 이때 관계 <span class="math inline">\(\overset{slim}{\sim}\)</span> 은 <span class="math inline">\(X\)</span>에서 정의가능한 모든 코시수열들의 집합 <span class="math inline">\({\cal C}_ X\)</span> 에서 <strong><em>equivalence relation</em></strong> 이 된다고 한다. (증명은 알아서) 따라서 이걸 이용하면 거리공간에서 <span class="math inline">\(slim\)</span> 의 관계를 가지는 임의의 두 수열은 같은 극한을 가진다는 결론이 나온다. (이것도 잘 따져보자.)</p>
<p><code>-</code> 잠시 <strong>(1)</strong> 바이너리-릴레이션(<strong><em>binary relation</em></strong>), <strong>(2)</strong> 이퀴배런스-릴레이션(<strong><em>equivalence relation</em></strong>), <strong>(3)</strong> 이퀴배런스-클래스(<strong><em>equivalence class</em></strong>) 그리고 <strong>(4)</strong> 코션트셋(<strong><em>quotient set</em></strong>)에 대하여 설명하고 넘어가겠다.</p>
<p><strong>(1)</strong> 집합 <span class="math inline">\({\cal C}_ X\)</span> 의 두 원소 <span class="math inline">\(\{a_n\}\)</span>, <span class="math inline">\(\{b_n\}\)</span> 간 바이너리-릴레이션 <span class="math inline">\(R\)</span>이 존재한다는 문장은 집합론적인 언어로 표현가능하다. 구체적으로는 <span class="math inline">\(R\)</span>을 곱집합 <span class="math inline">\({\cal C}_ X \times {\cal C}_ X\)</span> 의 적당한 부분집합으로 설정하고 순서쌍 <span class="math inline">\(\big(\{a_n\},\{b_n\}\big)\)</span> 이 <span class="math inline">\(R\)</span> 의 원소라는 식으로 표현한다. 예를 들면 아래와 같은 식으로 말이다.</p>
<p>$ {a_n} <sub>and</sub> {b_n} <sub>has</sub> a<sub>relation</sub> with~ R \ ({a_n},{b_n}) R _ X _ X \ {a_n} {b_n}$</p>
<p><strong>(2)</strong> 그리고 <span class="math inline">\({\cal C}_ X\)</span> 위에서의 바이너리-릴레이션 <span class="math inline">\(R\)</span>이 <strong><em>(i) reflexivity (ii) symmetricity (iii) transitivity</em></strong> 를 만족하면 이 릴레이션을 특별히 이퀴배런스-릴레이션 이라고 말한다.</p>
<p><strong>(3)</strong> 그리고 아래와 같이 <span class="math inline">\({\cal C}_ X\)</span> 에서 <span class="math inline">\(\{a_n\}\)</span> 과 이퀴배런스-릴레이션을 가지는 원소들을 모아놓은 집합을 생각할 수 있다. <span class="math display">\[\big[\{a_n\}\big]_ R:=\big\{ \{x_n\} : \{x_n\} \overset{R}{\sim} \{a_n\} ~and~ \{x_n\} \in {\cal C}_ X \big\}\]</span></p>
<p>이 집합을 <span class="math inline">\(\{a_n\}\)</span>의 <strong><em>equivalence class on <span class="math inline">\({\cal C}_ X\)</span> by <span class="math inline">\(R\)</span></em></strong> 이라고 부른다. 보통은 <span class="math inline">\(R\)</span>을 생략하여 <span class="math inline">\(\big[\{a_n\}\big]\)</span>와 같이만 표현하지만 나는 기호의 명확성을 위해서 관계까지 명시하였다.</p>
<p><strong>(4)</strong> 이퀴배런스-클래스는 본질적으로 파티션과 밀접한 연관이 있다. 여기에서 클래스 <span class="math inline">\({\cal P}_ A\)</span> 가 집합 <span class="math inline">\(A\)</span>의 파티션이란 의미는 클래스 <span class="math inline">\({\cal P}_ A\)</span> 에 속한 모든 원소의 합이 <span class="math inline">\(A\)</span> 이며 클래스 <span class="math inline">\({\cal P}_ A\)</span> 의 각 원소는 서로 배타적이라는 의미이다. 이퀴배런스-클래스가 그럼 왜 파티션과 관련이 있을까? 그것은 어떠한 집합에서 이퀴배런스-릴레이션이 존재하면 그 집합을 배타적인 이퀴배런스-클래스의 합집합으로 표현가능하기 때문이다. 즉 이퀴배런스-릴레이션 혹은 이퀴배런-클래스의 존재는 파티션의 존재를 임플라이 한다. 그리고 이러한 파티션을 이퀴배런스-릴레이션 <span class="math inline">\(R\)</span>에 의해 생성된 <strong><em>quotient set</em></strong> 혹은 <strong><em>quotient space</em></strong> 라고 한다. 관계 <span class="math inline">\(R\)</span>에 의한 <span class="math inline">\(A\)</span>의 코션트 셋은 기호로 <span class="math inline">\(A ~\overset{R}{\sim}\)</span> 와 같이 쓴다. 예를들어 <span class="math display">\[\begin{align}
{\cal C}_ X ~ /\overset{slim}{\sim}
\end{align}\]</span> 은 집합 <span class="math inline">\(X\)</span> 상에서 존재하는 코시수열들의 집합 <span class="math inline">\({\cal C}_ X\)</span> 에서 이퀴배런스-릴레이션 <span class="math inline">\(slim\)</span> 에 의해서 생성된 코션트셋을 의미한다.</p>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>정확하게는 <span class="math inline">\(\cal O\)</span>-오픈셋<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>공집합이 오픈셋이므로<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><span class="math inline">\(\mathbb{R}\)</span>이 오픈셋이므로<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>다만 이것은 위상공간을 <span class="math inline">\((\mathbb{R},{\cal O})\)</span>로 생각하였을때 이야기이고 위상공간을 <span class="math inline">\((\mathbb{R},2^{\mathbb{R}})\)</span>로 생각한다면 <span class="math inline">\(\{p\}\)</span> 도 오픈셋이 된다.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><span class="math inline">\({\cal T}=\{\emptyset, X\}\)</span>로 설정한다면 이 조건은 당연히 성립하지 않겠지?<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>즉 <span class="math inline">\((X,{\cal T}_4)\)</span>가 countable한 base를 가진다면<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>