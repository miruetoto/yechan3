<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="신록예찬">
<meta name="dcterms.date" content="2022-12-27">

<title>yechan3 - [CGSP] Chap 12.2.1: Power Spectral Density</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">yechan3</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/miruetoto/yechan3"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[CGSP] Chap 12.2.1: Power Spectral Density</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>신록예찬 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 27, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#power-spectral-density" id="toc-power-spectral-density" class="nav-link active" data-scroll-target="#power-spectral-density">12.2.1. Power Spectral Density</a></li>
  <li><a href="#power-spectral-density-estimators" id="toc-power-spectral-density-estimators" class="nav-link" data-scroll-target="#power-spectral-density-estimators">12.3. Power Spectral Density Estimators</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="power-spectral-density" class="level1">
<h1>12.2.1. Power Spectral Density</h1>
<blockquote class="blockquote">
<p><span class="citation" data-cites="djuric2018cooperative">Djuric and Richard (<a href="#ref-djuric2018cooperative" role="doc-biblioref">2018</a>)</span> 의 Chap 12.2.1, Chap 12.3</p>
</blockquote>
<p><strong>Definition 12.3.</strong> The PSD of a random process <span class="math inline">\({\bf x}\)</span> that is stationary with respect to GSO <span class="math inline">\({\bf S}={\bf V}{\bf \Lambda}{\bf V}^H\)</span> is the nonnegative <span class="math inline">\(N \times 1\)</span> vector <span class="math inline">\({\bf p}\)</span></p>
<p><span class="math display">\[{\bf p}:=\text{diag}\big({\bf V}^H {\bf C}_{\bf x}{\bf V} \big).\]</span></p>
<p>OversObserve that because <span class="math inline">\({\bf C}_{\bf x}\)</span> is diagonalized by <span class="math inline">\({\bf V}\)</span> the matrix <span class="math inline">\({\bf V}^H{\bf C}_{\bf x}{\bf V}\)</span> is diagonal and it follows that the PSD in above equation corresponds to the eigenvalues of the positive semidefinite covariance matrix <span class="math inline">\({\bf C}_{\bf x}\)</span>. Thus, above equation is equivalent to</p>
<p><span class="math display">\[{\bf C}_{\bf x}={\bf V}\text{diag}({\bf p}){\bf V}^H.\]</span></p>
<p>Zero-mean white noise is an example of a random process that is stationary with respect to any graph shift <span class="math inline">\({\bf S}\)</span>. The PSD of white noise with covariance <span class="math inline">\(\mathbb{E}[{\bf n}{\bf n}^H] = \sigma^2{\bf I}\)</span> is <span class="math inline">\({\bf p} = \sigma^2{\bf 1}\)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Also notice that, by definition, any random process <span class="math inline">\({\bf x}\)</span> is stationary with respect to the shift <span class="math inline">\({\bf S} = {\bf C}_{\bf x}\)</span> defined by its covariance matrix, with corresponding PSD <span class="math inline">\({\bf p} = \text{diag}({\bf \Lambda})\)</span>. This can be exploited in the context of network topology inference. Given a set of graph signals <span class="math inline">\(\{{\bf x}_r\}_{r=1}^R\)</span> it is common to infer the underlying topology by building a graph <span class="math inline">\({\cal G}_{corr}\)</span> whose edge weights correspond to cross-correlations among the entries of the signals. In that case, the process generating those signals is stationary in the shift given by the adjacency of <span class="math inline">\({\cal G}_{corr}\)</span>; see <span class="citation" data-cites="segarra2017network">Segarra et al. (<a href="#ref-segarra2017network" role="doc-biblioref">2017</a>)</span> for details. A random process x is also stationary with respect to the shift given by its precision matrix, which is defined as the (pseudo-)inverse <span class="math inline">\({\bf \Theta}= {\bf C}^{\dagger}_{\bf x}\)</span>. The PSD, in this case, is <span class="math inline">\({\bf p} = \text{diag}(\Lambda)^{\dagger}\)</span>. This is particularly important when <span class="math inline">\({\bf x}\)</span> is a Gaussian Markov Random Field (GMRF) whose Markovian dependence is captured by the unweighted graph <span class="math inline">\({\cal G}_{MF}\)</span>. It is well known <span class="citation" data-cites="segarra2017network">Segarra et al. (<a href="#ref-segarra2017network" role="doc-biblioref">2017</a>)</span> Ch. 19 that in these cases <span class="math inline">\({\bf \Theta}_{i,j}\)</span> can be nonzero only if <span class="math inline">\((i,j)\)</span> is either a link of <span class="math inline">\({\cal G}_{MF}\)</span> , or an element in the diagonal. Thus, any GMRF is stationary with respect to the sparse shift <span class="math inline">\({\bf S} = {\bf \Theta}\)</span>, which captures the conditional dependence between the elements of <span class="math inline">\({\bf x}\)</span>. Two important properties that hold for random processes in time can be shown to be true as well for the PSD of graph processes.</p>
<p><strong>Property 12.1</strong> Let <span class="math inline">\({\bf x}\)</span> be stationary in <span class="math inline">\({\bf S}\)</span> with covariance <span class="math inline">\({\bf C}_{\bf x}\)</span> and PSD <span class="math inline">\({\bf p}_x\)</span>. Consider a filter <span class="math inline">\({\bf H}\)</span> with frequency response <span class="math inline">\(\tilde{\bf h}\)</span> and define <span class="math inline">\({\bf y}:={\bf H}{\bf x}\)</span>. Then, the process <span class="math inline">\({\bf y}\)</span>:</p>
<ol type="a">
<li><p>Is stationary in <span class="math inline">\({\bf S}\)</span> with covariance <span class="math inline">\({\bf C}_{\bf y}= {\bf H}{\bf C}_{\bf x}{\bf H}^H\)</span>.</p></li>
<li><p>Has a PSD given by <span class="math inline">\({\bf p}_{\bf y}=|\tilde{\bf h}|^2 \circ {\bf p}_{\bf x}\)</span>, where <span class="math inline">\(|\cdot|^2\)</span> is applied elementwise.</p></li>
</ol>
<p><strong>Property 12.2</strong> Given a process <span class="math inline">\({\bf x}\)</span> stationary in <span class="math inline">\({\bf S}={\bf V}{\bf \Lambda}{\bf V}^H\)</span> with PSD <span class="math inline">\({\bf p}\)</span>, define the GFT process as <span class="math inline">\(\tilde{\bf x}={\bf V}^H{\bf x}\)</span>. Then, it holds that <span class="math inline">\(\tilde{\bf x}\)</span> is uncorrelated and its covariance matrix is</p>
<p><span class="math display">\[{\bf C}_{\tilde{\bf x}}:= \mathbb{E}\left[\tilde{\bf x}\tilde{\bf x}^H \right]=\mathbb{E}\left[({\bf V}^H{\bf x})({\bf V}^H{\bf x})^H \right]=\text{diag}({\bf p}).\]</span></p>
<p>Property 12.1 is a statement of the spectral convolution theorem for graph signals. Property 12.2 is fundamental to motivate the analysis and modeling of stationary graph processes in the frequency domain, which we undertake in the remainder of this chapter. It also shows that if a process <span class="math inline">\({\bf x}\)</span> is stationary in the shift <span class="math inline">\({\bf S} = {\bf V}{\bf \Lambda}{\bf V}^H\)</span>, then the GFT <span class="math inline">\({\bf V}^H\)</span> provides the Karhunen-Loève expansion of the process.</p>
<p>The concept of stationarity and, consequently, that of PSD can be extended to processes defined jointly in a graph and over time. Before we review this extension in the ensuing section, we discuss requirements on the first moment of stationary graph processes.</p>
<p><strong>The mean of stationary graph processes</strong>. While Definitions 12.1 and 12.2 assume that the random process <span class="math inline">\({\bf x}\)</span> has mean <span class="math inline">\(\tilde{\bf x} := \mathbb{E}[{\bf x}] = {\bf 0}\)</span>, traditional stationary time processes are allowed to have a (nonzero) constant mean <span class="math inline">\(\bar{\bf x} = \alpha{\bf 1}\)</span>, with <span class="math inline">\(\alpha\)</span> being an arbitrary scalar. Stationary graph processes, by contrast, are required to have a first-order moment of the form <span class="math inline">\(\bar{\bf x} = \alpha {\bf v}_k\)</span>, i.e., a scaled version of an eigenvector of <span class="math inline">\({\bf S}\)</span>. This choice: (i) takes into account the structure of the underlying graph; (ii) maintains the validity of Property 12.1; and (iii) encompasses the case <span class="math inline">\({\bf v}_k = {\bf 1}\)</span> when <span class="math inline">\({\bf S}\)</span> is either the adjacency matrix of a directed cycle or the Laplacian of any graph, recovering the classical first-order requirement for weak stationarity.</p>
</section>
<section id="power-spectral-density-estimators" class="level1">
<h1>12.3. Power Spectral Density Estimators</h1>
<p>We can exploit the fact that <span class="math inline">\({\bf x}\)</span> is a stationary graph process in <span class="math inline">\({\bf S} = {\bf V}\text{diag}({\bf \Lambda}){\bf V}^H\)</span> to design efficient estimators of the covariance <span class="math inline">\({\bf C}_{\bf x}\)</span>. In particular, instead of estimating <span class="math inline">\({\bf C}_{\bf x}\)</span> directly, which has <span class="math inline">\(N(N + 1)/2\)</span> degrees of freedom, one can estimate <span class="math inline">\({\bf p}\)</span> first, which only has <span class="math inline">\({\bf N}\)</span> degrees of freedom, and then leverage that <span class="math inline">\({\bf C}_{\bf x} = {\bf V}\text{diag}({\bf p}){\bf V}^H\)</span>. Motivated by this, the focus of this section is on estimating <span class="math inline">\({\bf p}\)</span>, the PSD of a stationary random graph process <span class="math inline">\({\bf x}\)</span>, using as input either one or a few realizations <span class="math inline">\(\{{\bf x}_r\}_{r=1}^R\)</span> of <span class="math inline">\({\bf x}\)</span>. To illustrate the developments in Sections 12.3 and 12.4, we will use as a running example a random process defined on the well-known Zachary’s Karate club network [28] (Figs. 12.3 and 12.4). As shown in Fig. 12.4, this graph consists of 34 nodes or members of the club and 78 undirected edges symbolizing friendships among members.2</p>
</section>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>ㅁㄴㅇㄹ</p>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-djuric2018cooperative" class="csl-entry" role="doc-biblioentry">
Djuric, Petar, and Cédric Richard. 2018. <em>Cooperative and Graph Signal Processing: Principles and Applications</em>. Academic Press.
</div>
<div id="ref-segarra2017network" class="csl-entry" role="doc-biblioentry">
Segarra, Santiago, Antonio G Marques, Gonzalo Mateos, and Alejandro Ribeiro. 2017. <span>“Network Topology Inference from Spectral Templates.”</span> <em>IEEE Transactions on Signal and Information Processing over Networks</em> 3 (3): 467–83.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p><span class="math inline">\({\bf 1}\)</span> is length <span class="math inline">\(N\)</span> vector with all elements are 1<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="miruetoto/yechan3" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>