<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.280">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="신록예찬">
<meta name="dcterms.date" content="2022-12-27">

<title>yechan3 - [CGSP] Chap 12.2.1: Power Spectral Density</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">yechan3</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/miruetoto/yechan3"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">[CGSP] Chap 12.2.1: Power Spectral Density</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>신록예찬 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 27, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preliminary-study" id="toc-preliminary-study" class="nav-link active" data-scroll-target="#preliminary-study">Preliminary Study</a>
  <ul class="collapse">
  <li><a href="#kronecker-product" id="toc-kronecker-product" class="nav-link" data-scroll-target="#kronecker-product">Kronecker product</a></li>
  <li><a href="#khatrirao-product" id="toc-khatrirao-product" class="nav-link" data-scroll-target="#khatrirao-product">Khatri–Rao product</a></li>
  </ul></li>
  <li><a href="#power-spectral-density" id="toc-power-spectral-density" class="nav-link" data-scroll-target="#power-spectral-density">12.2.1. Power Spectral Density</a></li>
  <li><a href="#power-spectral-density-estimators" id="toc-power-spectral-density-estimators" class="nav-link" data-scroll-target="#power-spectral-density-estimators">12.3. Power Spectral Density Estimators</a>
  <ul class="collapse">
  <li><a href="#nonparametric-psd-estimators" id="toc-nonparametric-psd-estimators" class="nav-link" data-scroll-target="#nonparametric-psd-estimators">Nonparametric PSD estimators</a>
  <ul class="collapse">
  <li><a href="#periodogram-correlogram-and-ls-estimator" id="toc-periodogram-correlogram-and-ls-estimator" class="nav-link" data-scroll-target="#periodogram-correlogram-and-ls-estimator">Periodogram, correlogram, and LS estimator</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="preliminary-study" class="level1">
<h1>Preliminary Study</h1>
<section id="kronecker-product" class="level2">
<h2 class="anchored" data-anchor-id="kronecker-product">Kronecker product</h2>
<p>크로네커곱의 정의는 아래와 같다.</p>
<p><span class="math display">\[{\bf A} \otimes {\bf B}
=\begin{bmatrix}
a_{11}{\bf B} &amp; a_{12}{\bf B} &amp; \dots &amp; a_{1m}{\bf B} \\
a_{21}{\bf B} &amp; a_{22}{\bf B} &amp; \dots &amp; a_{2m}{\bf B} \\
\dots &amp; \dots &amp; \dots &amp; \dots \\
a_{n1}{\bf B} &amp; a_{n2}{\bf B} &amp; \dots &amp; a_{nm}{\bf B} \\
\end{bmatrix}\]</span></p>
<p>두 행렬 <span class="math inline">\({\bf A}_{m\times n}\)</span>, <span class="math inline">\({\bf B}_{p\times q}\)</span>의 크로네커곱 <span class="math inline">\({\bf A}\otimes {\bf B}\)</span>의 차원은 <span class="math inline">\(mp \times nq\)</span> 가 된다. 계산예시는 아래와 같다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2022-12-27-CGSP-Chap-12-2-1-PSD_files/figure-html/5663bf73-f717-4d07-96e8-c926fb6359c0-1-856d291e-9401-4ca2-84e0-269d7cd2eac7.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">위키에서 긁은 예제, 글씨가 좀 작음</figcaption><p></p>
</figure>
</div>
<p>크로네커곱에 대한 성질들이 위키에 많이 있으니 참고하면 좋다.</p>
</section>
<section id="khatrirao-product" class="level2">
<h2 class="anchored" data-anchor-id="khatrirao-product">Khatri–Rao product</h2>
<p>카트리라오곱은 매트릭스 <span class="math inline">\({\bf A}\)</span>와 <span class="math inline">\({\bf B}\)</span>가 같은 차원의 블락매트릭스로 정의될때 각 서브매트릭스의 크로네커 곱으로 정의된다. 정의와 계산예시는 아래와 같다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2022-12-27-CGSP-Chap-12-2-1-PSD_files/figure-html/9b272351-038c-40ff-91d7-c16abab167be-1-7617bfb3-8b35-4b60-a609-25a593b62838.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">예시1: 위키에서 긁은 그림</figcaption><p></p>
</figure>
</div>
<p>또 다른 계산예시는 아래와 같다.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2022-12-27-CGSP-Chap-12-2-1-PSD_files/figure-html/dafb4ee2-42f6-4570-901b-d2fcc05cde32-1-f7f2fde4-ceb3-41e1-8580-036cb36951cc.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">예시2: 위키에서 긁은 그림</figcaption><p></p>
</figure>
</div>
</section>
</section>
<section id="power-spectral-density" class="level1">
<h1>12.2.1. Power Spectral Density</h1>
<blockquote class="blockquote">
<p><span class="citation" data-cites="djuric2018cooperative">Djuric and Richard (<a href="#ref-djuric2018cooperative" role="doc-biblioref">2018</a>)</span> 의 Chap 12.2.1, Chap 12.3</p>
</blockquote>
<p><strong>Definition 12.3.</strong> The PSD of a random process <span class="math inline">\({\bf x}\)</span> that is stationary with respect to GSO <span class="math inline">\({\bf S}={\bf V}{\bf \Lambda}{\bf V}^H\)</span> is the nonnegative <span class="math inline">\(N \times 1\)</span> vector <span class="math inline">\({\bf p}\)</span></p>
<p><span class="math display">\[{\bf p}:=\text{diag}\big({\bf V}^H {\bf C}_{\bf x}{\bf V} \big).\]</span></p>
<p>OversObserve that because <span class="math inline">\({\bf C}_{\bf x}\)</span> is diagonalized by <span class="math inline">\({\bf V}\)</span> the matrix <span class="math inline">\({\bf V}^H{\bf C}_{\bf x}{\bf V}\)</span> is diagonal and it follows that the PSD in above equation corresponds to the eigenvalues of the positive semidefinite covariance matrix <span class="math inline">\({\bf C}_{\bf x}\)</span>. Thus, above equation is equivalent to</p>
<p><span class="math display">\[{\bf C}_{\bf x}={\bf V}\text{diag}({\bf p}){\bf V}^H.\]</span></p>
<p>Zero-mean white noise is an example of a random process that is stationary with respect to any graph shift <span class="math inline">\({\bf S}\)</span>. The PSD of white noise with covariance <span class="math inline">\(\mathbb{E}[{\bf n}{\bf n}^H] = \sigma^2{\bf I}\)</span> is <span class="math inline">\({\bf p} = \sigma^2{\bf 1}\)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Also notice that, by definition, any random process <span class="math inline">\({\bf x}\)</span> is stationary with respect to the shift <span class="math inline">\({\bf S} = {\bf C}_{\bf x}\)</span> defined by its covariance matrix, with corresponding PSD <span class="math inline">\({\bf p} = \text{diag}({\bf \Lambda})\)</span>. This can be exploited in the context of network topology inference. Given a set of graph signals <span class="math inline">\(\{{\bf x}_r\}_{r=1}^R\)</span> it is common to infer the underlying topology by building a graph <span class="math inline">\({\cal G}_{corr}\)</span> whose edge weights correspond to cross-correlations among the entries of the signals. In that case, the process generating those signals is stationary in the shift given by the adjacency of <span class="math inline">\({\cal G}_{corr}\)</span>; see <span class="citation" data-cites="segarra2017network">Segarra et al. (<a href="#ref-segarra2017network" role="doc-biblioref">2017</a>)</span> for details. A random process x is also stationary with respect to the shift given by its precision matrix, which is defined as the (pseudo-)inverse <span class="math inline">\({\bf \Theta}= {\bf C}^{\dagger}_{\bf x}\)</span>. The PSD, in this case, is <span class="math inline">\({\bf p} = \text{diag}(\Lambda)^{\dagger}\)</span>. This is particularly important when <span class="math inline">\({\bf x}\)</span> is a Gaussian Markov Random Field (GMRF) whose Markovian dependence is captured by the unweighted graph <span class="math inline">\({\cal G}_{MF}\)</span>. It is well known <span class="citation" data-cites="segarra2017network">Segarra et al. (<a href="#ref-segarra2017network" role="doc-biblioref">2017</a>)</span> Ch. 19 that in these cases <span class="math inline">\({\bf \Theta}_{i,j}\)</span> can be nonzero only if <span class="math inline">\((i,j)\)</span> is either a link of <span class="math inline">\({\cal G}_{MF}\)</span> , or an element in the diagonal. Thus, any GMRF is stationary with respect to the sparse shift <span class="math inline">\({\bf S} = {\bf \Theta}\)</span>, which captures the conditional dependence between the elements of <span class="math inline">\({\bf x}\)</span>. Two important properties that hold for random processes in time can be shown to be true as well for the PSD of graph processes.</p>
<p><strong>Property 12.1</strong> Let <span class="math inline">\({\bf x}\)</span> be stationary in <span class="math inline">\({\bf S}\)</span> with covariance <span class="math inline">\({\bf C}_{\bf x}\)</span> and PSD <span class="math inline">\({\bf p}_x\)</span>. Consider a filter <span class="math inline">\({\bf H}\)</span> with frequency response <span class="math inline">\(\tilde{\bf h}\)</span> and define <span class="math inline">\({\bf y}:={\bf H}{\bf x}\)</span>. Then, the process <span class="math inline">\({\bf y}\)</span>:</p>
<ol type="a">
<li><p>Is stationary in <span class="math inline">\({\bf S}\)</span> with covariance <span class="math inline">\({\bf C}_{\bf y}= {\bf H}{\bf C}_{\bf x}{\bf H}^H\)</span>.</p></li>
<li><p>Has a PSD given by <span class="math inline">\({\bf p}_{\bf y}=|\tilde{\bf h}|^2 \circ {\bf p}_{\bf x}\)</span>, where <span class="math inline">\(|\cdot|^2\)</span> is applied elementwise.</p></li>
</ol>
<blockquote class="blockquote">
<p>Here <span class="math inline">\(\circ\)</span> is elementwise matrix product</p>
</blockquote>
<p><strong>Property 12.2</strong> Given a process <span class="math inline">\({\bf x}\)</span> stationary in <span class="math inline">\({\bf S}={\bf V}{\bf \Lambda}{\bf V}^H\)</span> with PSD <span class="math inline">\({\bf p}\)</span>, define the GFT process as <span class="math inline">\(\tilde{\bf x}={\bf V}^H{\bf x}\)</span>. Then, it holds that <span class="math inline">\(\tilde{\bf x}\)</span> is uncorrelated and its covariance matrix is</p>
<p><span class="math display">\[{\bf C}_{\tilde{\bf x}}:= \mathbb{E}\left[\tilde{\bf x}\tilde{\bf x}^H \right]=\mathbb{E}\left[({\bf V}^H{\bf x})({\bf V}^H{\bf x})^H \right]=\text{diag}({\bf p}).\]</span></p>
<p>Property 12.1 is a statement of the spectral convolution theorem for graph signals. Property 12.2 is fundamental to motivate the analysis and modeling of stationary graph processes in the frequency domain, which we undertake in the remainder of this chapter. It also shows that if a process <span class="math inline">\({\bf x}\)</span> is stationary in the shift <span class="math inline">\({\bf S} = {\bf V}{\bf \Lambda}{\bf V}^H\)</span>, then the GFT <span class="math inline">\({\bf V}^H\)</span> provides the Karhunen-Loève expansion of the process.</p>
<p>The concept of stationarity and, consequently, that of PSD can be extended to processes defined jointly in a graph and over time. Before we review this extension in the ensuing section, we discuss requirements on the first moment of stationary graph processes.</p>
<p><strong>The mean of stationary graph processes</strong>. While Definitions 12.1 and 12.2 assume that the random process <span class="math inline">\({\bf x}\)</span> has mean <span class="math inline">\(\tilde{\bf x} := \mathbb{E}[{\bf x}] = {\bf 0}\)</span>, traditional stationary time processes are allowed to have a (nonzero) constant mean <span class="math inline">\(\bar{\bf x} = \alpha{\bf 1}\)</span>, with <span class="math inline">\(\alpha\)</span> being an arbitrary scalar. Stationary graph processes, by contrast, are required to have a first-order moment of the form <span class="math inline">\(\bar{\bf x} = \alpha {\bf v}_k\)</span>, i.e., a scaled version of an eigenvector of <span class="math inline">\({\bf S}\)</span>. This choice: (i) takes into account the structure of the underlying graph; (ii) maintains the validity of Property 12.1; and (iii) encompasses the case <span class="math inline">\({\bf v}_k = {\bf 1}\)</span> when <span class="math inline">\({\bf S}\)</span> is either the adjacency matrix of a directed cycle or the Laplacian of any graph, recovering the classical first-order requirement for weak stationarity.</p>
</section>
<section id="power-spectral-density-estimators" class="level1">
<h1>12.3. Power Spectral Density Estimators</h1>
<p>We can exploit the fact that <span class="math inline">\({\bf x}\)</span> is a stationary graph process in <span class="math inline">\({\bf S} = {\bf V}\text{diag}({\bf \Lambda}){\bf V}^H\)</span> to design efficient estimators of the covariance <span class="math inline">\({\bf C}_{\bf x}\)</span>. In particular, instead of estimating <span class="math inline">\({\bf C}_{\bf x}\)</span> directly, which has <span class="math inline">\(N(N + 1)/2\)</span> degrees of freedom, one can estimate <span class="math inline">\({\bf p}\)</span> first, which only has <span class="math inline">\(N\)</span> degrees of freedom, and then leverage that <span class="math inline">\({\bf C}_{\bf x} = {\bf V}\text{diag}({\bf p}){\bf V}^H\)</span>. Motivated by this, the focus of this section is on estimating <span class="math inline">\({\bf p}\)</span>, the PSD of a stationary random graph process <span class="math inline">\({\bf x}\)</span>, using as input either one or a few realizations <span class="math inline">\(\{{\bf x}_r\}_{r=1}^R\)</span> of <span class="math inline">\({\bf x}\)</span>. To illustrate the developments in Sections 12.3 and 12.4, we will use as a running example a random process defined on the well-known Zachary’s Karate club network <span class="citation" data-cites="zachary1977information">Zachary (<a href="#ref-zachary1977information" role="doc-biblioref">1977</a>)</span> (Figs. 12.3 and 12.4). As shown in Fig. 12.4, this graph consists of 34 nodes or members of the club and 78 undirected edges symbolizing friendships among members.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2022-12-27-CGSP-Chap-12-2-1-PSD_files/figure-html/1f505a23-5b9f-4dbb-a3f8-03c093652bc1-1-27b3f625-0405-4e7f-b677-35aa91a95a68.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">그림12.3(교재에서 긁어온 그림): Power spectral density estimation. All estimators are based on the same random process defined on the Karate club network <span class="citation" data-cites="zachary1977information">(<a href="#ref-zachary1977information" role="doc-biblioref">Zachary 1977</a>)</span>. (A) Periodogram estimation with different numbers of observations. (B) Windowed average periodogram from a single realization and a different number of windows. (C) Windowed average periodogram for four windows and a varying number of realizations. (D) Parametric MA estimation for 1 and 10 realizations.</figcaption><p></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2022-12-27-CGSP-Chap-12-2-1-PSD_files/figure-html/871b9550-848f-4d49-9a99-26a5c2d85595-1-f9528ecc-9143-4e3b-bff7-18e4b23a9651.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">그림12.4(교재에서 긁어온 그림): PSD estimation from a subset of nodes. Estimators are based on a random process defined on the Karate club network <span class="citation" data-cites="zachary1977information">(<a href="#ref-zachary1977information" role="doc-biblioref">Zachary 1977</a>)</span>. (A) Graph sampling for nonparametric PSD estimation. Here, 20 out of 34 nodes are observed. The sampled nodes are highlighted by the circles around the nodes. (B) Nonparametric PSD estimation based on observations from 20 nodes and 100 data snapshots. (C) Graph sampling for parametric MA PSD estimation. Here, 4 out of 34 nodes are observed. (D) Parametric MA PSD estimation based on observations from 4 nodes and 100 data snapshots.</figcaption><p></p>
</figure>
</div>
<section id="nonparametric-psd-estimators" class="level2">
<h2 class="anchored" data-anchor-id="nonparametric-psd-estimators">Nonparametric PSD estimators</h2>
<p>Nonparametric estimators—as opposed to their parametric counterparts—do not assume any specific generating model on the process <span class="math inline">\({\bf x}\)</span>. This more agnostic view of <span class="math inline">\({\bf x}\)</span> comes with the price of needing, in general, to observe more graph signals to achieve satisfactory performance. In this section, we extend to the graph setting the periodogram, the correlogram, and the least-squares (LS) estimator, which are classical unbiased nonparametric estimators. Moreover, for the special case where the observations are Gaussian, we derive the Cramér-Rao lower bound. We also discuss the windowed average periodogram, which attains a better performance when a few observations are available by introducing bias in a controlled manner while drastically reducing the variance.</p>
<section id="periodogram-correlogram-and-ls-estimator" class="level3">
<h3 class="anchored" data-anchor-id="periodogram-correlogram-and-ls-estimator">Periodogram, correlogram, and LS estimator</h3>
<p>From <span class="math inline">\({\bf C}_{\tilde{\bf x}}:= \mathbb{E}\left[\tilde{\bf x}\tilde{\bf x}^H \right]=\mathbb{E}\left[({\bf V}^H{\bf x})({\bf V}^H{\bf x})^H \right]=\text{diag}({\bf p})\)</span> it follows that one may express the PSD as <span class="math inline">\({\bf p}=\mathbb{E}\left[|{\bf V}^H{\bf x}|^2\right]\)</span>. That is, the PSD is given by the expected value of the squared frequency components of the random process. This leads to a natural approach for the estimation of <span class="math inline">\({\bf p}\)</span> from a finite set of <span class="math inline">\(R\)</span> realizations of the process <span class="math inline">\({\bf x}\)</span>. Indeed, we compute the <span class="math inline">\({\bf GFT} \tilde{\bf x}_r = {\bf V}^H{\bf x}_r\)</span> of each observed signal <span class="math inline">\({\bf x}_r\)</span> and estimate <span class="math inline">\({\bf p}\)</span> as</p>
<p><span class="math display">\[
\hat{\bf p}_{pg}:= \frac{1}{R}\sum_{r=1}^R|\tilde{\bf x}_r|^2=\frac{1}{R}\sum_{r=1}^{R}|{\bf V}^H{\bf x}_{r}|^2.
\]</span></p>
<p>The estimator <span class="math inline">\(\hat{\bf p}_{pg}\)</span> is termed periodogram due to its evident similarity with its homonym<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> in classical estimation. It is simple to show that <span class="math inline">\({\bf p}_{pg}\)</span> is an unbiased estimator, that is, <span class="math inline">\(\mathbb{E}[\hat{\bf p}_{pg}]= {\bf p}\)</span>. A more detailed analysis of the performance of <span class="math inline">\(\hat{\bf p}_{pg}\)</span>, for the case where the observations are Gaussian, is given in Proposition 12.1.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>An alternative nonparametric estimation scheme, denominated correlogram, can be devised by starting from the definition of <span class="math inline">\({\bf p}\)</span> in</p>
<p><span class="math display">\[{\bf p}:=\text{diag}\big({\bf V}^H {\bf C}_{\bf x}{\bf V} \big).\]</span></p>
<p>Namely, one may substitute <span class="math inline">\({\bf C}_{\bf x}\)</span> in above equation by the sample covariance <span class="math inline">\(\hat{\bf C}_{\bf x} = \frac{1}{R}\sum_{r=1}^R{\bf x}_r{\bf x}_r^H\)</span> computed based on the available observations to obtain</p>
<p><span class="math display">\[\hat{\bf p}_{cg}:= \text{diag}\left({\bf V}^H \hat{\bf C}_{\bf x}{\bf V} \right):=\text{diag}\left[{\bf V}^H\big[ \frac{1}{R}\sum_{r=1}^R{\bf x}_r{\bf x}_r^H\big]{\bf V} \right].\]</span></p>
<p>Notice that the matrix <span class="math inline">\({\bf V}^H\hat{\bf C}_{\bf x}{\bf V}\)</span> is in general, not diagonal because the eigenbasis of <span class="math inline">\(\hat{\bf C}_{\bf x}\)</span> differs from <span class="math inline">\({\bf V}\)</span>, the eigenbasis of <span class="math inline">\({\bf C}_{\bf x}\)</span>. Nonetheless, we keep only the diagonal elements <span class="math inline">\({\bf v}_i^H \hat{\bf C}_{\bf x}{\bf v}_i\)</span> for <span class="math inline">\(i = 1, \dots , N\)</span> as our PSD estimator. It can be shown that the correlogram <span class="math inline">\({\bf p}_{cg}\)</span> and the periodogram <span class="math inline">\({\bf p}_{pg}\)</span> lead to identical estimators, as is the case in classical signal processing.</p>
<p>The correlogram can also be interpreted as an LS estimator. The decomposition in <span class="math inline">\({\bf C}_{\bf x}={\bf V}\text{diag}({\bf p}){\bf V}^H\)</span> allows a linear parameterization of the covariance matrix <span class="math inline">\({\bf C}_{\bf x}\)</span> as</p>
<p><span class="math display">\[
{\bf C}_{\bf x}({\bf p})=\sum_{i=1}^N p_i{\bf v}_i{\bf v}_i^H.
\]</span></p>
<p>This linear parametrization will also be useful for the sampling schemes developed in Section 12.4. Vectorizing <span class="math inline">\({\bf C}_{\bf x}\)</span> in <span class="math inline">\({\bf C}_{\bf x}({\bf p})=\sum_{i=1}^N p_i{\bf v}_i{\bf v}_i^H\)</span> results in a set of <span class="math inline">\(N^2\)</span> equations in <span class="math inline">\({\bf p}\)</span></p>
<p><span class="math display">\[
{\bf c}_{\bf x} = \text{vec}({\bf C}_{\bf x})=\sum_{i=1}^{N}p_i \text{vec}({\bf v}_i{\bf v}_i^H)={\bf G}_{np}{\bf p},
\]</span></p>
<p>where <span class="math inline">\(\text{vec}({\bf v}_i{\bf v}_i^H)={\bf v}_i^\ast \otimes {\bf v}_i\)</span>. Relying on the Khatri-Rao product, we then form the <span class="math inline">\(N^2 \times N\)</span> matrix <span class="math inline">\({\bf G}_{np}\)</span> as</p>
<p><span class="math display">\[
{\bf G}_{np}:= \left[{\bf v}_1^\ast \otimes {\bf v}_1, \dots, {\bf v}_N^\ast \otimes {\bf v}_N \right] = {\bf V}^\ast \odot {\bf V}.
\]</span></p>
<blockquote class="blockquote">
<p>Here <span class="math inline">\(\otimes\)</span> denote the Kronecker matrix product and <span class="math inline">\(\odot\)</span> denote the Khatri-Rao matrix product.</p>
</blockquote>
<p>Using the sample covariance matrix <span class="math inline">\(\hat{\bf C}_{\bf x}\)</span> as an estimate of <span class="math inline">\({\bf C}_{\bf x}\)</span>, we can <em>match</em> the estimated covariance vector <span class="math inline">\(\hat{\bf c}_{\bf x}=\text{vec}(\hat{\bf C}_{\bf x})\)</span> to the true covariance vector <span class="math inline">\({\bf c}_{\bf x}\)</span> in the LS sense as</p>
<p><span class="math display">\[
\hat{\bf p}_{ls} = \underset{\bf p}{\operatorname{argmin}} \|\hat{\bf c}_{\bf x}-{\bf G}_{np}{\bf p}\|_2^2=({\bf G}_{np}^H{\bf G}_{np})^{-1}{\bf G}_{np}^H\hat{\bf c}_{\bf x}.
\]</span></p>
<p>In other words, the LS estimator minimizes the squared error <span class="math inline">\(\text{tr}\left[\big(\hat{\bf C}_{\bf x} − \hat{\bf C}_{\bf x}({\bf p})\big)^T \big(\hat{\bf C}_{\bf x} − \hat{\bf C}_{\bf x}({\bf p})\big)\right]\)</span>. From expression <span class="math inline">\(\hat{\bf p}_{ls} = \underset{\bf p}{\operatorname{argmin}} \|\hat{\bf c}_{\bf x}-{\bf G}_{np}{\bf p}\|_2^2=({\bf G}_{np}^H{\bf G}_{np})^{-1}{\bf G}_{np}^H\hat{\bf c}_{\bf x}\)</span> it can be shown that the <span class="math inline">\(i\)</span>th element of <span class="math inline">\(\hat{\bf p}_{ls}\)</span> is <span class="math inline">\({\bf v}_i^H \hat{\bf C}_{\bf x} {\bf v}_i\)</span>. Combining this with Eq.</p>
<p><span class="math display">\[\hat{\bf p}_{cg}:= \text{diag}\left({\bf V}^H \hat{\bf C}_{\bf x}{\bf V} \right):=\text{diag}\left[{\bf V}^H\big[ \frac{1}{R}\sum_{r=1}^R{\bf x}_r{\bf x}_r^H\big]{\bf V} \right]\]</span></p>
<p>we get that the LS estimator <span class="math inline">\(\hat{\bf p}_{ls}\)</span> and the correlogram <span class="math inline">\(\hat{\bf p}_{cg}\)</span> —and hence the periodogram as well— are all identical estimators. The estimators derived in this subsection do not assume any data distribution and are well suited for cases where the data probability density function is not available. In what follows, we provide performance bounds for these estimators under the condition that the observed signals are Gaussian.</p>
</section>
</section>
</section>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>GSO <span class="math inline">\({\bf S}={\bf V}{\bf \Lambda}{\bf V}^H\)</span>에 대하여 정상인 시계열 <span class="math inline">\({\bf x}\)</span>를 고려한다. 이 신호의 그래프퓨리에 변환<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>은 아래와 같이 구할 수 있다.</p>
<p><span class="math display">\[\tilde{\bf x}={\bf GFT} {\bf x} = {\bf V}^H{\bf x}\]</span></p>
<p>여기에서 <span class="math inline">\(\tilde{\bf x}\)</span>를 <span class="math inline">\({\bf x}\)</span>의 주파수응답(frequency representation)이라고 부른다.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> 우리는 주파수와 주파수응답, 시각화 하고 싶을 때가 많다. 이유는 이러한 시각화는 <span class="math inline">\({\bf x}\)</span>가 어떠한 요소들의 합으로 이루어져 있는지 파악할 수 있게 도움을 주기 때문이다. 하지만 보통은 주파수응답을 바로 사용하기보다 주파수응답의 제곱값을 사용한다.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> 즉 아래의 값에 관심이 있다.</p>
<p><span class="math display">\[{\bf p}=\mathbb{E}\left[|{\bf V}^H{\bf x}|^2\right]\]</span></p>
<p>여기에서 <span class="math inline">\({\bf p}\)</span>를 PSD (power spectrum density) 라고 한다.</p>
<p><span class="math display">\[{\bf p}:=\text{diag}\big({\bf V}^H {\bf C}_{\bf x}{\bf V} \big).\]</span></p>
<p>여기에서 <span class="math inline">\({\bf C}_{\bf x}\)</span>는 <span class="math inline">\({\bf x}\)</span>의 공분산 매트릭스이다.</p>
<p><strong>Definition 12.3.</strong> The PSD of a random process <span class="math inline">\({\bf x}\)</span> that is stationary with respect to GSO <span class="math inline">\({\bf S}={\bf V}{\bf \Lambda}{\bf V}^H\)</span> is the nonnegative <span class="math inline">\(N \times 1\)</span> vector <span class="math inline">\({\bf p}\)</span></p>
<p><span class="math display">\[{\bf p}:=\text{diag}\big({\bf V}^H {\bf C}_{\bf x}{\bf V} \big).\]</span></p>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-djuric2018cooperative" class="csl-entry" role="doc-biblioentry">
Djuric, Petar, and Cédric Richard. 2018. <em>Cooperative and Graph Signal Processing: Principles and Applications</em>. Academic Press.
</div>
<div id="ref-segarra2017network" class="csl-entry" role="doc-biblioentry">
Segarra, Santiago, Antonio G Marques, Gonzalo Mateos, and Alejandro Ribeiro. 2017. <span>“Network Topology Inference from Spectral Templates.”</span> <em>IEEE Transactions on Signal and Information Processing over Networks</em> 3 (3): 467–83.
</div>
<div id="ref-zachary1977information" class="csl-entry" role="doc-biblioentry">
Zachary, Wayne W. 1977. <span>“An Information Flow Model for Conflict and Fission in Small Groups.”</span> <em>Journal of Anthropological Research</em> 33 (4): 452–73.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p><span class="math inline">\({\bf 1}\)</span> is length <span class="math inline">\(N\)</span> vector with all elements are 1<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>동음이의어<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Proposition 12.1은 뒤에 다루는데 <span class="math inline">\(\hat{\bf p}_{pg}\)</span>의 분산에 대한 서술이 있음. 분산은 <span class="math inline">\(\mathbb{V}[\hat{\bf p}_{pg}]=\frac{2}{R}\text{diag}^2({\bf p})\)</span>와 같음<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>좀 더 정확하게는 <span class="math inline">\({\bf V}^H\)</span> 에 대한 그래프 변환이라고 한다<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>이 <span class="math inline">\(\tilde{\bf x}\)</span>를 그냥 graph Fourier transform이라고 부르는 사람도 많다. 즉 그래프퓨리에변환이 (1) 변환매트릭스 <span class="math inline">\({\bf GFT}\)</span>자체를 지칭할때도 있고 (2) 트랜스폼된 결과 <span class="math inline">\(\tilde{\bf x}\)</span>를 지칭할때도 있음. 교재에서는 변환은 graph Fourier transform, 그리고 변환된 결과는 <span class="math inline">\({\bf x}\)</span>의 주파수응답이라고 한다.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>주파수응답의 제곱값은 주파수응답과 유사하게 해석할 수 있고, 여러가지 이론적 성질을 만족하기 때문에 그러하다<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="miruetoto/yechan3" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>