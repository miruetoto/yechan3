<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.520">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="신록예찬">
<meta name="dcterms.date" content="2023-07-19">

<title>신록예찬’s Blog - (연구&amp;보람) 신용카드거래 사기탐지 – 관련연구 리뷰</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">신록예찬’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DL2022/"> 
<span class="menu-text">DL2022</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/AP2023/"> 
<span class="menu-text">AP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/PP2023/"> 
<span class="menu-text">PP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DV2023/"> 
<span class="menu-text">DV2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/MP2023/"> 
<span class="menu-text">MP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/SC2022/"> 
<span class="menu-text">SC2022</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DS2022/"> 
<span class="menu-text">DS2022</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/SP2023/"> 
<span class="menu-text">SP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/IR2021/"> 
<span class="menu-text">IR2021</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://miruetoto.github.io/yechan/"> 
<span class="menu-text">yechan</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://miruetoto.github.io/yechan2/"> 
<span class="menu-text">yechan2</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/miruetoto/yechan3"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">(연구&amp;보람) 신용카드거래 사기탐지 – 관련연구 리뷰</li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../메모.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">메모</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../공부.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">공부</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">연구</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../규빈.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">규빈</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../재인.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">재인</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../서연.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">서연</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../보람.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">보람</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../지윤.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">지윤</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../자료.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">자료</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#ref" id="toc-ref" class="nav-link active" data-scroll-target="#ref">Ref</a></li>
  <li><a href="#dou2020enhancing" id="toc-dou2020enhancing" class="nav-link" data-scroll-target="#dou2020enhancing"><span class="citation" data-cites="dou2020enhancing">Dou et al. (2020)</span></a>
  <ul class="collapse">
  <li><a href="#abstract" id="toc-abstract" class="nav-link" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  </ul></li>
  <li><a href="#liu2018heterogeneous" id="toc-liu2018heterogeneous" class="nav-link" data-scroll-target="#liu2018heterogeneous"><span class="citation" data-cites="liu2018heterogeneous">Liu et al. (2018)</span></a></li>
  <li><a href="#liu2019geniepath" id="toc-liu2019geniepath" class="nav-link" data-scroll-target="#liu2019geniepath"><span class="citation" data-cites="liu2019geniepath">Liu et al. (2019)</span></a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="2023-07-19-(연구&amp;보람) 신용카드거래 사기탐지 -- 관련연구 리뷰.out.ipynb" download="2023-07-19-(연구&amp;보람) 신용카드거래 사기탐지 -- 관련연구 리뷰.out.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">(연구&amp;보람) 신용카드거래 사기탐지 – 관련연구 리뷰</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>신록예찬 </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 19, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="ref" class="level1">
<h1>Ref</h1>
</section>
<section id="dou2020enhancing" class="level1 page-columns page-full">
<h1><span class="citation" data-cites="dou2020enhancing">Dou et al. (<a href="#ref-dou2020enhancing" role="doc-biblioref">2020</a>)</span></h1>
<div class="no-row-height column-margin column-container"><div id="ref-dou2020enhancing" class="csl-entry" role="listitem">
Dou, Yingtong, Zhiwei Liu, Li Sun, Yutong Deng, Hao Peng, and Philip S Yu. 2020. <span>“Enhancing Graph Neural Network-Based Fraud Detectors Against Camouflaged Fraudsters.”</span> In <em>Proceedings of the 29th ACM International Conference on Information &amp; Knowledge Management</em>, 315–24.
</div></div><p><a href="https://arxiv.org/abs/2008.08692" class="uri">https://arxiv.org/abs/2008.08692</a></p>
<p><a href="https://ytongdou.com/files/cikm20slides.pdf" class="uri">https://ytongdou.com/files/cikm20slides.pdf</a></p>
<p><a href="https://github.com/YingtongDou/CARE-GNN" class="uri">https://github.com/YingtongDou/CARE-GNN</a></p>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>이 논문에서는 최근 몇 년간 그래프 신경망(Graph Neural Networks, GNNs)이 사기 탐지 문제에 널리 적용되어, 다양한 관계를 통해 이웃 정보를 집계함으로써 노드의 수상성을 밝혀내는 것을 소개하고 있습니다. 그러나 몇몇 이전 연구들은 사기꾼들의 가장 큰 문제인 위장 행위(camouflage behavior)에 주목하지 않았습니다. 이러한 위장 행위는 GNN 기반 사기 탐지기의 집계 과정에서 성능을 저하시킬 수 있습니다. 따라서 이 논문에서는 최근의 경험적 연구를 기반으로 두 가지 유형의 위장 행위, 즉 특성 위장과 관계 위장을 소개하고 있습니다. 기존의 GNN은 이러한 두 가지 위장 행위에 대응하지 않았기 때문에 사기 탐지 문제에서 성능이 떨어지는 것입니다. 이에 대응하여 새로운 모델인 CAmouflage-REsistant GNN (CARE-GNN)을 제안하고 있으며, 이 모델은 위장 행위에 대응하기 위해 세 가지 독특한 모듈을 포함하고 있습니다. 구체적으로, 먼저 정보성이 있는 이웃 노드를 찾기 위해 레이블 기반 유사도 측정 방법을 고안합니다. 그런 다음, 강화 학습 (Reinforcement Learning, RL)을 활용하여 선택할 최적의 이웃 수를 결정합니다. 마지막으로, 다양한 관계 사이에서 선택된 이웃들을 함께 집계합니다. 두 개의 실제 사기 데이터셋에 대한 포괄적인 실험을 통해 RL 알고리즘의 효과를 입증하였습니다. 제안된 CARE-GNN은 최첨단 GNN 및 GNN 기반 사기 탐지기보다 뛰어난 성능을 보여줍니다. 또한, 모든 GNN 기반 사기 탐지기를 통합하여 오픈 소스 도구 상자(https://github.com/YingtongDou/CARE-GNN)로 제공하고 있습니다. CARE-GNN 코드와 데이터셋을 이용할 수 있습니다.]</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>인터넷 서비스의 번창과 함께 다양한 유형의 사기 행위도 발생하고 있습니다 [14]. 사기꾼들은 일반 사용자로 위장하여 안티 사기 시스템을 우회하고 불명확한 정보를 퍼뜨리거나 최종 사용자의 개인정보를 빼앗습니다 [32]. 이러한 사기 행위를 탐지하기 위해 그래프 기반 방법이 학계 [7, 21, 38]와 산업계 [2, 28, 50] 모두에서 효과적인 접근 방법이 되었습니다. 그래프 기반 방법은 서로 다른 관계로 엔티티를 연결하고, 동일한 목표를 가진 사기꾼들은 서로 연결되기 때문에 이러한 엔티티들의 수상성을 그래프 수준에서 드러낼 수 있습니다 [1].</p>
<p>최근에는 그래프 신경망(Graph Neural Networks, GNNs)의 발전으로 많은 GNN 기반 사기 탐지기들이 제안되었습니다. (예: GCN [17], GAT [34], 그리고 GraphSAGE [12]) 이들은 의견 사기 [19, 25, 39], 금융 사기 [23, 24, 37], 모바일 사기 [41], 그리고 사이버 범죄 [48]를 탐지하기 위해 사용됩니다. 기존의 전통적인 그래프 기반 접근 방법과는 달리, GNN 기반 방법은 이웃 정보를 집계하여 중심 노드의 표현을 학습합니다. 이들은 end-to-end 및 반지도 학습 방식으로 훈련될 수 있으며, 이는 많은 특성 엔지니어링과 데이터 주석 비용을 절약할 수 있습니다.</p>
<p>그러나 기존의 GNN 기반 사기 탐지 연구들은 GNN을 제한적인 범위에서만 적용하면서 사기꾼들의 위장 행위를 무시하고 있습니다. 이러한 위장 행위는 연구자들 [8, 15, 16, 49]과 실무자들 [2, 19, 41] 양쪽에서 큰 관심을 받고 있습니다. 한편, 이론적인 연구들은 그래프에 노이즈가 있는 노드와 엣지가 있는 경우 GNN의 한계와 취약점을 입증하고 있습니다 [3, 4, 13, 33]. 따라서, 위장된 사기꾼들에 대응하지 못한다면 GNN 기반 사기 탐지기의 성능을 저하시킬 수 있습니다. 최근 몇몇 연구들 [4, 9, 13, 25, 41]은 비슷한 도전에 주목했지만, 이들의 해결책은 사기 탐지 문제에 적합하지 않거나 GNN의 end-to-end 학습 방식을 파괴하는 경우가 있습니다.</p>
</section>
</section>
<section id="liu2018heterogeneous" class="level1 page-columns page-full">
<h1><span class="citation" data-cites="liu2018heterogeneous">Liu et al. (<a href="#ref-liu2018heterogeneous" role="doc-biblioref">2018</a>)</span></h1>
<div class="no-row-height column-margin column-container"><div id="ref-liu2018heterogeneous" class="csl-entry" role="listitem">
Liu, Ziqi, Chaochao Chen, Xinxing Yang, Jun Zhou, Xiaolong Li, and Le Song. 2018. <span>“Heterogeneous Graph Neural Networks for Malicious Account Detection.”</span> In <em>Proceedings of the 27th ACM International Conference on Information and Knowledge Management</em>, 2077–85.
</div></div><p><a href="https://arxiv.org/abs/1802.00910" class="uri">https://arxiv.org/abs/1802.00910</a></p>
<p>이 논문에서는 불규칙한 도메인에 속하는 데이터, 즉 그래프를 포함한 표현 학습 작업을 연구합니다. 많은 데이터는 그래프의 형태를 가지고 있습니다. 예를 들어, 소셜 네트워크 (Perozzi, Al-Rfou, and Skiena 2014), 인용 네트워크 (Sen et al.&nbsp;2008), 생물학적 네트워크 (Zitnik and Leskovec 2017), 그리고 거래 네트워크 (Liu et al.&nbsp;2017) 등이 있습니다. 우리는 노드마다 이웃의 순서가 학습 작업에 무관한 순열 불변(permutation invariant) 속성을 가지는 그래프에 관심을 가지고 있습니다. 이는 시계열 그래프와 대조적입니다 (Kostakos 2009).</p>
<p>합성곱 신경망(Convolutional Neural Networks, CNN)은 이미지 (He et al.&nbsp;2016a)와 시퀀스 (Gehring et al.&nbsp;2016)와 관련된 다양한 응용 분야에서 성공적으로 증명되었습니다. 최근에는 합성곱을 그래프에 일반화하려는 노력과 관심이 문헌에서 등장하고 있습니다 (Hammond, Vandergheynst, and Gribonval 2011; Defferrard, Bresson, and Vandergheynst 2016; Kipf and Welling 2016; Hamilton, Ying, and Leskovec 2017a), 이로 인해 새로운 도전과제가 발생합니다.</p>
<p><code>-</code> Suppose followings:</p>
<ul>
<li>Assume a graph <span class="math inline">\({\cal G} =({\cal V},{\cal E})\)</span> with <span class="math inline">\(N\)</span> nodes <span class="math inline">\(i \in {\cal V}\)</span> and <span class="math inline">\(|{\cal E}|\)</span> edges <span class="math inline">\((i,j)\in {\cal E}\)</span></li>
<li><span class="math inline">\(A \in \mathbb{R}^{N\times N}\)</span> is the adjacency matrix of <span class="math inline">\({\cal G}\)</span>.</li>
<li><span class="math inline">\(D\in \mathbb{R}^{N\times N}\)</span> is the digagonal node degree matrix where <span class="math inline">\(D_{ii} = \sum_{ij}A_ij\)</span>.</li>
<li><span class="math inline">\(X \in \mathbb{R}^{N\times P}\)</span> is matrix of node features.</li>
</ul>
<p><code>-</code> Consider the calculation as follows:<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;그래프 컨볼루션</p></li></div><p><span class="math display">\[H^{(t+1)} = \sigma\big(\phi(A)H^{(t)}W^{(t)}\big)\]</span></p>
</section>
<section id="liu2019geniepath" class="level1 page-columns page-full">
<h1><span class="citation" data-cites="liu2019geniepath">Liu et al. (<a href="#ref-liu2019geniepath" role="doc-biblioref">2019</a>)</span></h1>


<div class="no-row-height column-margin column-container"><div id="ref-liu2019geniepath" class="csl-entry" role="listitem">
Liu, Ziqi, Chaochao Chen, Longfei Li, Jun Zhou, Xiaolong Li, Le Song, and Yuan Qi. 2019. <span>“Geniepath: Graph Neural Networks with Adaptive Receptive Paths.”</span> In <em>Proceedings of the AAAI Conference on Artificial Intelligence</em>, 33:4424–31. 01.
</div></div>
</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="miruetoto/yechan3" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>