<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.533">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="신록예찬">
<meta name="dcterms.date" content="2024-08-12">

<title>신록예찬’s Blog - (공부) CGSP – Chap 12.2: Weakly Stationary Graph Processes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">신록예찬’s Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DL2024/"> 
<span class="menu-text">DL2024</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/AP2023/"> 
<span class="menu-text">AP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/PP2024/"> 
<span class="menu-text">PP2024</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DV2023/"> 
<span class="menu-text">DV2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/MP2023/"> 
<span class="menu-text">MP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/SC2024/"> 
<span class="menu-text">SC2024</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/DS2022/"> 
<span class="menu-text">DS2022</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/SP2023/"> 
<span class="menu-text">SP2023</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://guebin.github.io/IR2021/"> 
<span class="menu-text">IR2021</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://miruetoto.github.io/yechan/"> 
<span class="menu-text">yechan</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://miruetoto.github.io/yechan2/"> 
<span class="menu-text">yechan2</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/miruetoto/yechan3"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">(공부) CGSP – Chap 12.2: Weakly Stationary Graph Processes</li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../메모.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">메모</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../공부.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">공부</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../연구.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">연구</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../자료.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">자료</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preliminary-study" id="toc-preliminary-study" class="nav-link active" data-scroll-target="#preliminary-study">Preliminary Study</a>
  <ul class="collapse">
  <li><a href="#simultaneously-diagonalizable" id="toc-simultaneously-diagonalizable" class="nav-link" data-scroll-target="#simultaneously-diagonalizable">Simultaneously Diagonalizable</a></li>
  <li><a href="#commute" id="toc-commute" class="nav-link" data-scroll-target="#commute">Commute</a></li>
  <li><a href="#shift-invariant-filter" id="toc-shift-invariant-filter" class="nav-link" data-scroll-target="#shift-invariant-filter">Shift Invariant Filter</a></li>
  </ul></li>
  <li><a href="#weakly-stationary-graph-processes" id="toc-weakly-stationary-graph-processes" class="nav-link" data-scroll-target="#weakly-stationary-graph-processes">Weakly Stationary Graph Processes</a>
  <ul class="collapse">
  <li><a href="#coexisting-approaches" id="toc-coexisting-approaches" class="nav-link" data-scroll-target="#coexisting-approaches">Coexisting Approaches</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#psd" id="toc-psd" class="nav-link" data-scroll-target="#psd">12.2.1. PSD</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="2022-12-26-Chap-12.2.out.ipynb" download="2022-12-26-Chap-12.2.out.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">(공부) CGSP – Chap 12.2: Weakly Stationary Graph Processes</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>신록예찬 </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 12, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div id="c7b0b758-bf6a-4cce-b497-8eea9349146b" class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>using LinearAlgebra, DSP</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="preliminary-study" class="level1 page-columns page-full">
<h1>Preliminary Study</h1>
<section id="simultaneously-diagonalizable" class="level2">
<h2 class="anchored" data-anchor-id="simultaneously-diagonalizable">Simultaneously Diagonalizable</h2>
<p>매트릭스 <span class="math inline">\({\bf A}\)</span>와 <span class="math inline">\({\bf B}\)</span>가 대각화 가능하다는 것은 아래의 표현을 만족하는 적당한 invertible matrix <span class="math inline">\({\bf \Psi}_A\)</span>, <span class="math inline">\({\bf \Psi}_B\)</span>와 대각행렬 <span class="math inline">\({\bf \Lambda}_A\)</span>, <span class="math inline">\({\bf \Lambda}_B\)</span>가 존재한다는 의미가 된다.</p>
<p><span class="math display">\[{\bf A} = {\bf V}_{A} {\bf \Lambda}_A {\bf V}_{A}^{-1}\]</span></p>
<p><span class="math display">\[{\bf B} = {\bf V}_{B} {\bf \Lambda}_B {\bf V}_{B}^{-1}\]</span></p>
<p>그리고 만약에 <span class="math inline">\({\bf V}_{A}={\bf V}_{B}\)</span>이라면 즉</p>
<p><span class="math display">\[{\bf A} = {\bf V} {\bf \Lambda}_A {\bf V}^{-1}\]</span></p>
<p><span class="math display">\[{\bf B} = {\bf V} {\bf \Lambda}_B {\bf V}^{-1}\]</span></p>
<p>이라면 <span class="math inline">\(\{{\bf A},{\bf B}\}\)</span>가 simultaneously diagonalzable 하다고 표현한다.</p>
</section>
<section id="commute" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="commute">Commute</h2>
<p>두 matrix <span class="math inline">\({\bf A}\)</span>와 <span class="math inline">\({\bf B}\)</span>에 대하여</p>
<p><span class="math display">\[{\bf A}{\bf B}= {\bf B}{\bf A}\]</span></p>
<p>인 관계가 성립하면 두 매트릭스가 commute 한다고 표현한다. 그런데 <span class="math inline">\({\bf A}{\bf B}={\bf A}{\bf B}\)</span>의 조건은 <span class="math inline">\({\bf A}, {\bf B}\)</span>가 동시대각화가능할 (simultaneously diagonalzable) 조건과 같다. <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 따라서 simultaneously diagonalzable 는 commute와 같은 말이라 생각해도 무방하다.</p>
<div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;필요충분조건이다.</p></li></div><blockquote class="blockquote">
<p>참고: <a href="https://en.wikipedia.org/wiki/Diagonalizable_matrix">위키피디아..</a></p>
</blockquote>
</section>
<section id="shift-invariant-filter" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="shift-invariant-filter">Shift Invariant Filter</h2>
<blockquote class="blockquote page-columns page-full">
<p>ref: <span class="citation" data-cites="djuric2018cooperative">Djuric and Richard (<a href="#ref-djuric2018cooperative" role="doc-biblioref">2018</a>)</span> Chap 8.3 의 내용 중 일부</p>
<div class="no-row-height column-margin column-container"><div id="ref-djuric2018cooperative" class="csl-entry" role="listitem">
Djuric, Petar, and Cédric Richard. 2018. <em>Cooperative and Graph Signal Processing: Principles and Applications</em>. Academic Press.
</div></div></blockquote>
<p>Define the matrix <span class="math inline">\({\bf B}\)</span> as periodic shift matrix such that</p>
<p><span class="math display">\[
{\bf B} = \begin{bmatrix}
0 &amp; 0 &amp; 0 &amp; \dots  &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 0 &amp; \dots &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; \dots &amp; 0 &amp; 0 \\
\dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots &amp; \dots\\
0 &amp; 0 &amp; \dots &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \dots &amp; 0 &amp; 1 &amp; 0 \\
\end{bmatrix}.\]</span></p>
<p>A generic filter <span class="math inline">\({\boldsymbol h}\)</span> is given by its <span class="math inline">\(z\)</span>-transform</p>
<p><span class="math display">\[h(z)=h_0z^0+h_1z^{-1}+\cdots +h_{N-1}z^{-(N-1)}\]</span></p>
<p>where <span class="math inline">\(s_{n-1}=z^{-1}s_n\)</span>. In vector notation, and with respect to the standard basis <span class="math inline">\({\bf I}\)</span>, the filter is represented by the matrix <span class="math inline">\({\bf H}\)</span>, a polynomial in the cyclic shift</p>
<p><span class="math display">\[{\bf H}=h({\bf B})=h_0{\bf B}^0+h_1{\bf B}^1+\cdots+h_{N-1}{\bf B}^{N-1}.\]</span></p>
<p>Filters are <em>shift invariant</em> iff</p>
<p><span class="math display">\[z\cdot h(z) = h(z)\cdot z\]</span></p>
<p>or from the matrix representation</p>
<p><span class="math display">\[{\bf B}h({\bf B})=h({\bf B}){\bf B}.\]</span></p>
<p><strong>Example</strong></p>
<p>Let <span class="math inline">\({\bf B}\)</span> as</p>
<div id="7719fd71-1b68-4e4c-89be-c991442d3ed1" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>B<span class="op">=</span> [<span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> </span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> </span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> </span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">0</span> </span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span> </span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="50">
<pre><code>7×7 Matrix{Int64}:
 0  1  0  0  0  0  0
 0  0  1  0  0  0  0
 0  0  0  1  0  0  0
 0  0  0  0  1  0  0
 0  0  0  0  0  1  0
 0  0  0  0  0  0  1
 1  0  0  0  0  0  0</code></pre>
</div>
</div>
<p>Define <span class="math inline">\({\boldsymbol h}\)</span> as</p>
<div id="ba0e5579-0265-44dc-9bd6-6c2011591b13" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>h <span class="op">=</span> [<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>,<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>,<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="51">
<pre><code>3-element Vector{Float64}:
 0.3333333333333333
 0.3333333333333333
 0.3333333333333333</code></pre>
</div>
</div>
<p>Furthermore define <span class="math inline">\({\bf H}=h({\bf B})=h_0{\bf B}^0+h_1{\bf B}^1+h_2{\bf B}^2\)</span></p>
<div id="26e8d20a-b032-44ec-a916-0001a9318f71" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>H <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>)<span class="op">*</span>B<span class="op">^</span><span class="dv">0</span> <span class="op">+</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>)<span class="op">*</span>B<span class="op">^</span><span class="dv">1</span> <span class="op">+</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>)<span class="op">*</span>B<span class="op">^</span><span class="dv">2</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="54">
<pre><code>7×7 Matrix{Float64}:
 0.333333  0.333333  0.333333  0.0       0.0       0.0       0.0
 0.0       0.333333  0.333333  0.333333  0.0       0.0       0.0
 0.0       0.0       0.333333  0.333333  0.333333  0.0       0.0
 0.0       0.0       0.0       0.333333  0.333333  0.333333  0.0
 0.0       0.0       0.0       0.0       0.333333  0.333333  0.333333
 0.333333  0.0       0.0       0.0       0.0       0.333333  0.333333
 0.333333  0.333333  0.0       0.0       0.0       0.0       0.333333</code></pre>
</div>
</div>
<p>Observe following:</p>
<div id="ffefd08f-107e-4608-ba04-9427b097d23e" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>B<span class="op">*</span>H <span class="op">==</span> H<span class="op">*</span>B </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="55">
<pre><code>true</code></pre>
</div>
</div>
<p>Thus, filter <span class="math inline">\({\boldsymbol h}\)</span> is shift invariant filter and matrix <span class="math inline">\({\bf H}\)</span> is shift invariant operator.</p>
<p><em>note:</em> <span class="math inline">\({\boldsymbol h}\)</span> is moving average filter.</p>
<p><em>note:</em> for any <span class="math inline">\({\bf x}\)</span>, <span class="math inline">\({\bf H}{\bf x}\)</span> is definded by</p>
<p><span class="math display">\[\left[\frac{x_{n-1}+x_n+x_1}{3},\frac{x_n+x_1+x_2}{3},\dots,\frac{x_{n-3}+x_{n-2}+x_n}{3}\right].\]</span></p>
<div id="2062d8c7-2519-4ccf-a270-621c8685f664" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>x <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>]</span>
<span id="cb10-2"><a href="#cb10-2"></a>H<span class="op">*</span>x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="48">
<pre><code>7-element Vector{Float64}:
 1.0
 1.0
 1.3333333333333333
 1.6666666666666665
 2.0
 1.6666666666666665
 1.3333333333333333</code></pre>
</div>
</div>
<p><em>note:</em> In some sense, the matrix <span class="math inline">\({\bf H}{\bf x}\)</span> can be thought as generalized version of <span class="math inline">\({\boldsymbol h}\star {\bf x}\)</span> where <span class="math inline">\(\star\)</span> is convolution up to shift</p>
<div id="bf2c1294-ffda-42e4-9852-1782905df8c1" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>conv(h,x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="57">
<pre><code>9-element Vector{Float64}:
 0.3333333333333334
 0.6666666666666667
 1.0
 1.0
 1.3333333333333333
 1.6666666666666667
 2.0
 1.3333333333333333
 0.6666666666666667</code></pre>
</div>
</div>
<p>Finally, we observe that, from the Cayley-Hamilton Theorem, <span class="math inline">\({\bf B}\)</span> satisfies its characteristic polynomial <span class="math inline">\(\Delta({\bf B})\)</span>, where <span class="math inline">\(\Delta(\lambda)\)</span> is the determinant of <span class="math inline">\(\lambda{\bf I}-{\bf B}\)</span>. The characteristic polynomial <span class="math inline">\(\Delta({\bf B})\)</span> has degree <span class="math inline">\(N\)</span>, so, in DSP, as described so far, linear filters are (matrix) polynomial with degree at most <span class="math inline">\(N-1\)</span>.</p>
<blockquote class="blockquote">
<p>이 부분은 책에 써있길래 가져오긴 했는데, 무슨 의미인지 모르겠음</p>
</blockquote>
</section>
</section>
<section id="weakly-stationary-graph-processes" class="level1 page-columns page-full">
<h1>Weakly Stationary Graph Processes</h1>
<p>We extend three equivalent definitions of weak stationary in time to the graph domain, the most common being the invariance of the first and second moments to time shifts.</p>
<p><strong>Definition 12.1.</strong> Given a normal shift operator <span class="math inline">\({\bf S}\)</span>, a zero-mean random process <span class="math inline">\({\bf x}\)</span> is weakly stationary with respect to <span class="math inline">\({\bf S}\)</span> if it can be written as the response of a linear shift-invariant graph filter <span class="math inline">\({\bf H}=\sum_{l=0}^{N-1}h_l{\bf S}^l\)</span> to a zero-mean white input <span class="math inline">\({\bf n}\)</span>.</p>
<p><strong>Definition 12.2.</strong> Given a normal shift operator <span class="math inline">\({\bf S}\)</span>, a zero-mean random process <span class="math inline">\({\bf x}\)</span> is weakly stationary with respect to <span class="math inline">\({\bf S}\)</span> is the following two equivalent properties hold</p>
<p><strong>(a)</strong> For any set of nonnegative integers <span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>, and <span class="math inline">\(c\leq b\)</span> it holds that</p>
<p><span class="math display">\[\mathbb{E} \bigg[ \big({\bf S}^a{\bf x}\big)\Big(\big({\bf S}^H)^b {\bf x}\Big)^H  \bigg]=\mathbb{E}\bigg[\big({\bf S}^{a+c}{\bf x}\big)\Big(\big({\bf S}^H\big)^{b-c}{\bf x} \Big)^H \bigg]\]</span></p>
<p><strong>(b)</strong> Matrices <span class="math inline">\({\bf C}_{\bf x}\)</span> and <span class="math inline">\({\bf S}\)</span> are simultaneously diagonalizable.</p>
<p>The statements in Definition 12.2 can indeed be shown to be equivalent <span class="citation" data-cites="marques2017stationary">(<a href="#ref-marques2017stationary" role="doc-biblioref">Marques et al. 2017</a>)</span>. Definition 12.2b characterizes stationarity from a graph frequency perspective by requiring the covariance <span class="math inline">\({\bf C}_{\bf x}\)</span> to be diagonalized by the GFT matrix <span class="math inline">\({\bf V}\)</span>. When particularized to time, Definition 12.2b requires <span class="math inline">\({\bf C}_{\bf x}\)</span> to be diagonalized by the Fourier matrix and, therefore, must be circulant. This fact is exploited in classical signal processing to define the PSD of a stationary process as the eigenvalues of the circulant covariance matrix, motivating the PSD definition in Section 12.2.1</p>
<div class="no-row-height column-margin column-container"></div><hr>
<p>(a)와 (b)의 동치성을 수식적으로 살펴보자.</p>
<p>먼저, (b) 조건에서 (a) 조건이 어떻게 유도되는지 보자.</p>
<ol start="2" type="a">
<li>조건은 자기상관 행렬 $ _{} = $와 시스템 행렬 $ $가 동시에 대각화 가능하다는 것을 의미한다. 이는 두 행렬이 같은 고유벡터 집합에 대해 대각화될 수 있음을 나타내며, 다음과 같은 고유벡터 $ $와 고유값 대각행렬 $ _S $ , $ _C $가 존재함을 의미한다:</li>
</ol>
<p><span class="math display">\[
\mathbf{S} = \mathbf{V} \mathbf{\Lambda}_S \mathbf{V}^H
\]</span></p>
<p><span class="math display">\[
\mathbf{C}_{\mathbf{x}} = \mathbf{V} \mathbf{\Lambda}_C \mathbf{V}^H
\]</span></p>
<p>이제 (a) 조건의 좌변을 계산해 보자:</p>
<p><span class="math display">\[
\mathbb{E}\left[\left(\mathbf{S}^a \mathbf{x}\right) \left(\left(\mathbf{S}^H\right)^b \mathbf{x}\right)^H\right]
\]</span></p>
<p><span class="math display">\[
= \mathbb{E}\left[\left(\mathbf{V} \mathbf{\Lambda}_S^a \mathbf{V}^H \mathbf{x}\right) \left(\mathbf{x}^H \mathbf{V} \mathbf{\Lambda}_S^b \mathbf{V}^H \right)\right]
\]</span></p>
<p><span class="math display">\[
= \mathbf{V} \mathbf{\Lambda}_S^a \mathbf{V}^H \mathbb{E}\left[\mathbf{x} \mathbf{x}^H\right] \mathbf{V}\mathbf{\Lambda}_S^b \mathbf{V}^H
\]</span></p>
<p><span class="math display">\[
= \mathbf{V} \mathbf{\Lambda}_S^a \mathbf{V}^H \mathbf{C}_{\mathbf{x}} \mathbf{V} \mathbf{\Lambda}_S^b \mathbf{V}^H
\]</span></p>
<p><span class="math display">\[
= \mathbf{V} \mathbf{\Lambda}_S^a \mathbf{\Lambda}_C \mathbf{\Lambda}_S^b \mathbf{V}^H
\]</span></p>
<p>같은 방식으로, (a) 조건의 우변을 계산하면:</p>
<p><span class="math display">\[
\mathbb{E}\left[\left(\mathbf{S}^{a+c} \mathbf{x}\right) \left(\left(\mathbf{S}^H\right)^{b-c} \mathbf{x}\right)^H\right]
\]</span></p>
<p><span class="math display">\[
= \mathbf{V} \mathbf{\Lambda}_S^{a+c} \mathbf{\Lambda}_C \mathbf{\Lambda}_S^{b-c} \mathbf{V}^H
\]</span></p>
<p>여기서 $ _S $와 $ <em>C $가 모두 대각행렬이므로, 두 결과는 동일하게 된다. 따라서 $ $와 $ </em>{} $가 동시에 대각화 가능하다는 조건은 (a) 조건을 만족함을 보인다.</p>
<ol type="a">
<li>조건에서 (b)를 유도하는 과정을 살펴보자.</li>
</ol>
<p>먼저, (a) 조건은 다음과 같다:</p>
<p><span class="math display">\[
\mathbb{E}\left[\left(\mathbf{S}^a \mathbf{x}\right) \left(\left(\mathbf{S}^H\right)^b \mathbf{x}\right)^H\right] = \mathbb{E}\left[\left(\mathbf{S}^{a+c} \mathbf{x}\right) \left(\left(\mathbf{S}^H\right)^{b-c} \mathbf{x}\right)^H\right]
\]</span></p>
<p><span class="math inline">\(a = 0\)</span>, <span class="math inline">\(b = 0\)</span>, <span class="math inline">\(c = 1\)</span>인 경우를 고려해 보자. 이 경우, (a) 조건은 다음과 같이 쓸 수 있다:</p>
<p><span class="math display">\[
\mathbb{E}\left[\mathbf{x}\mathbf{x}^H\right] = \mathbb{E}\left[\left(\mathbf{S} \mathbf{x}\right)\left(\mathbf{S}^H \mathbf{x}\right)^H\right]
\]</span></p>
<p>이 식은 다음과 같이 쓸 수 있다:</p>
<p><span class="math display">\[
\mathbf{C}_{\mathbf{x}} = \mathbf{S} \mathbf{C}_{\mathbf{x}} \mathbf{S}^H
\]</span></p>
<p>이 식은 $ $와 $ <em>{} $가 서로 가환한다는 의미를 가진다. 즉, $ $와 $ </em>{} $는 공통의 고유벡터를 가진다는 것을 의미한다. 이는 두 행렬이 동시에 대각화될 수 있음을 암시한다.</p>
<hr>
<p>Thus far, we have presented three extensions of the concept of stationarity into the realm of graph processes, two of which are equivalent and, hence, grouped in Definition 12.2. At this point, the attentive reader might have a natural inquiry. Are Definitions 12.1 and 12.2 equivalent for general graphs, as they are for stationarity in time? In fact, it can be shown that Definitions 12.1 and 12.2 are equivalent for any graph <span class="math inline">\({\bf S}\)</span> that is normal and whose eigenvalues are all distinct <span class="citation" data-cites="marques2017stationary">(<a href="#ref-marques2017stationary" role="doc-biblioref">Marques et al. 2017</a>)</span>. Follwing figure presents a concise summary of the definitions discussed in this section.</p>
<div class="no-row-height column-margin column-container"><div id="ref-marques2017stationary" class="csl-entry" role="listitem">
Marques, Antonio G, Santiago Segarra, Geert Leus, and Alejandro Ribeiro. 2017. <span>“Stationary Graph Processes and Spectral Estimation.”</span> <em>IEEE Transactions on Signal Processing</em> 65 (22): 5911–26.
</div></div><div class="img-fluid quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2022-12-26-Chap-12.2_files/figure-html/2bacb792-6dad-4d86-a9d0-1130727b88d1-1-fcc7a188-7a4c-4e41-b896-f1b6a1f6f87d.png" class="img-fluid figure-img"></p>
<figcaption>그림1: 교재에서 긁어온 다이어그램.</figcaption>
</figure>
</div>
<section id="coexisting-approaches" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="coexisting-approaches">Coexisting Approaches</h2>
<p>Stationary graph processes were first defined and analyzed in <span class="citation" data-cites="girault2015stationary">(<a href="#ref-girault2015stationary" role="doc-biblioref">Girault 2015</a>)</span>. The fundamental problem identified there is that GSOs do not preserve energy in general and therefore cannot be isometric <span class="citation" data-cites="gavili2017shift">(<a href="#ref-gavili2017shift" role="doc-biblioref">Gavili and Zhang 2017</a>)</span>. This problem is addressed in <span class="citation" data-cites="girault2015translation">(<a href="#ref-girault2015translation" role="doc-biblioref">Girault, Gonçalves, and Fleury 2015</a>)</span> with the definition of an isometric graph shift that preserves the eigenvector space of the Laplacian GSO but modifies its eigenvalues.</p>
<div class="no-row-height column-margin column-container"><div id="ref-girault2015stationary" class="csl-entry" role="listitem">
Girault, Benjamin. 2015. <span>“Stationary Graph Signals Using an Isometric Graph Translation.”</span> In <em>2015 23rd European Signal Processing Conference (EUSIPCO)</em>, 1516–20. IEEE.
</div><div id="ref-gavili2017shift" class="csl-entry" role="listitem">
Gavili, Adnan, and Xiao-Ping Zhang. 2017. <span>“On the Shift Operator, Graph Frequency, and Optimal Filtering in Graph Signal Processing.”</span> <em>IEEE Transactions on Signal Processing</em> 65 (23): 6303–18.
</div><div id="ref-girault2015translation" class="csl-entry" role="listitem">
Girault, Benjamin, Paulo Gonçalves, and Éric Fleury. 2015. <span>“Translation on Graphs: An Isometric Shift Operator.”</span> <em>IEEE Signal Processing Letters</em> 22 (12): 2416–20.
</div></div><p>A stationary graph process is then defined as one whose probability distributions are invariant with respect to multiplications with the isometric shift. One drawback of this approach is that the isometric shift is a complex-valued operator and has a sparsity structure (if any) different from <span class="math inline">\({\bf S}\)</span>. By contrast, the vertex-based definition in</p>
<p><span class="math display">\[\mathbb{E} \bigg[ \big({\bf S}^a{\bf x}\big)\Big(\big({\bf S}^H)^b {\bf x}\Big)^H  \bigg]=\mathbb{E}\bigg[\big({\bf S}^{a+c}{\bf x}\big)\Big(\big({\bf S}^H\big)^{b-c}{\bf x} \Big)^H \bigg]\]</span></p>
<p>is based on the original GSO <span class="math inline">\({\bf S}\)</span>, which is local and real-valued. As a result, above Eq. provides intuition on the relations between stationarity and locality, which can be leveraged to develop stationarity tests or estimation schemes that work with local information. Graph stationarity was also studied in <span class="citation" data-cites="perraudin2017stationary">(<a href="#ref-perraudin2017stationary" role="doc-biblioref">Perraudin and Vandergheynst 2017</a>)</span> where the requirement of having a covariance matrix diagonalizable by the eigenvectors of the Laplacian GSO is adopted as a definition. This condition is shown to be equivalent to statistical invariance with respect to the translation operator introduced in <span class="citation" data-cites="shuman2016vertex">(<a href="#ref-shuman2016vertex" role="doc-biblioref">Shuman, Ricaud, and Vandergheynst 2016</a>)</span>. When the shift <span class="math inline">\({\bf S}\)</span> coincides with the Laplacian of the graph and the eigenvalues of <span class="math inline">\({\bf S}\)</span> are all distinct, Definitions 12.1 and 12.2 are equivalent to those in <span class="citation" data-cites="girault2015stationary">Perraudin and Vandergheynst (<a href="#ref-perraudin2017stationary" role="doc-biblioref">2017</a>)</span>. Hence, the definitions presented here differ from <span class="citation" data-cites="perraudin2017stationary">(<a href="#ref-perraudin2017stationary" role="doc-biblioref">Perraudin and Vandergheynst 2017</a>)</span> in that we consider general normal shifts instead of Laplacians and that we see Definition 12.1 as a definition, not a property. These are mathematically minor differences that are important in practice though; see <span class="citation" data-cites="marques2017stationary">Segarra et al. (<a href="#ref-segarra2017network" role="doc-biblioref">2017</a>)</span> for more details.</p>
<div class="no-row-height column-margin column-container"><div id="ref-perraudin2017stationary" class="csl-entry" role="listitem">
Perraudin, Nathanaël, and Pierre Vandergheynst. 2017. <span>“Stationary Signal Processing on Graphs.”</span> <em>IEEE Transactions on Signal Processing</em> 65 (13): 3462–77.
</div><div id="ref-shuman2016vertex" class="csl-entry" role="listitem">
Shuman, David I, Benjamin Ricaud, and Pierre Vandergheynst. 2016. <span>“Vertex-Frequency Analysis on Graphs.”</span> <em>Applied and Computational Harmonic Analysis</em> 40 (2): 260–91.
</div><div id="ref-segarra2017network" class="csl-entry" role="listitem">
Segarra, Santiago, Antonio G Marques, Gonzalo Mateos, and Alejandro Ribeiro. 2017. <span>“Network Topology Inference from Spectral Templates.”</span> <em>IEEE Transactions on Signal and Information Processing over Networks</em> 3 (3): 467–83.
</div></div></section>
</section>
<section id="summary" class="level1 page-columns page-full">
<h1>Summary</h1>
<p>이 섹션에선 우리는 <span class="math inline">\(\bar{\bf x}:=\mathbb{E}[{\bf x}]={\bf 0}\)</span>을 가정한다. 일반적인 우리에게 익숙한 정상시계열의 정의는 아래와 같다.</p>
<p>(정의1) <span class="math inline">\({\bf x}\)</span>가 정상시계열이다. <span class="math inline">\(\overset{def}{\Longleftrightarrow}\)</span> 모든 <span class="math inline">\(l=0,1,2,\dots\)</span>에 대하여 <span class="math inline">\(\mathbb{E}[{\bf x}{\bf x}^H] = \mathbb{E}\big[({\bf B}^l{\bf x})({\bf B}^l{\bf x})^H \big]\)</span>이 성립한다.</p>
<p>또한 <span class="math inline">\({\bf x}\)</span>가 정상시계열이라면 적당한 white noise <span class="math inline">\({\bf n}\)</span>에 대하여 <span class="math inline">\({\bf x} = {\bf H}{\bf n}\)</span>를 만족하는 shift invariant operater <span class="math inline">\({\bf H}=\sum_{l=0}^{N-1}h_l {\bf B}^l\)</span>가 존재함이 알려져 있다. (Wold’s theorem의 특수한 형태인 듯) 이 정리를 마치 정의와 같이 사용하면 아래와 같이 시계열의 정상성을 정의할 수 있다.</p>
<p>(정의2) <span class="math inline">\({\bf x}\)</span>가 정상시계열이다. <span class="math inline">\(\overset{def}{\Longleftrightarrow}\)</span> 임의의 <span class="math inline">\({\bf n}\)</span>에 대하여 <span class="math inline">\({\bf x}={\bf H}{\bf n}\)</span>를 만족하는 shift invariant opertor <span class="math inline">\({\bf H}\)</span>가 항상 존재한다.</p>
<p>한편 <span class="math inline">\({\bf C}_{\bf x}=\mathbb{E}[{\bf x}{\bf x}^H]={\bf H}{\bf H}^H\)</span>와 같이 표현가능한데 <span class="math inline">\({\bf H}\)</span>와 <span class="math inline">\({\bf B}\)</span>는 같은 고유벡터행렬을 가지고<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> <span class="math inline">\({\bf H}^H{\bf H}\)</span>는 <span class="math inline">\({\bf H}\)</span>와 같은 고유벡터행렬을 가지므로<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> 결국 <span class="math inline">\({\bf C}_{\bf x}\)</span>와 <span class="math inline">\({\bf B}\)</span>는 같은 고유벡터 행렬을 가진다고 볼 수 있다. 따라서 아래와 같이 쓸 수 있다.</p>
<div class="no-row-height column-margin column-container"><li id="fn2"><p><sup>2</sup>&nbsp;shift invariant operator의 정의에 의하여 <span class="math inline">\({\bf H}{\bf B}={\bf B}{\bf H}\)</span>가 성립하니까</p></li><li id="fn3"><p><sup>3</sup>&nbsp;<span class="math inline">\({\bf H}{\bf H}^H={\bf \Psi}{\bf D}{\bf D}^H{\bf \Psi}^H\)</span>이니까, 여기에서 <span class="math inline">\({\bf D}\)</span>는 <span class="math inline">\({\bf H}\)</span>의 고유벡터행렬임</p></li></div><p><span class="math display">\[\begin{align}
{\bf C}_{\bf x} &amp; = {\bf \Psi} \cdot \text{적당한대각행렬} \cdot {\bf \Psi}^H \\
&amp;= {\bf DFT}^H \cdot \text{적당한대각행렬} \cdot {\bf DFT}
\end{align}\]</span></p>
<p>이러한 직관에서 아래와 같이 시계열의 정상성에 대한 세번째 정의를 이해할 수 있다.</p>
<p>(정의3) <span class="math inline">\({\bf x}\)</span>가 정상시계열이다. <span class="math inline">\(\overset{def}{\Longleftrightarrow}\)</span> <span class="math inline">\({\bf C}_{\bf x}\)</span>는 <span class="math inline">\({\bf DFT}\)</span> 행렬로 대각화 가능하다. (<span class="math inline">\({\bf C}_{\bf x}\)</span>와 <span class="math inline">\({\bf B}\)</span>는 같은 고유벡터 행렬을 가진다.)</p>
<p>정상시계열에 대한 세가지 정의는 아래와 같이 정상 그래프신호로 확장가능하다.</p>
<div class="img-fluid quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2022-12-26-Chap-12.2_files/figure-html/39a41707-b306-4492-a0b5-e02b4d7d7591-1-fcc7a188-7a4c-4e41-b896-f1b6a1f6f87d.png" class="img-fluid figure-img"></p>
<figcaption>그림1: 교재에서 긁어온 다이어그램.</figcaption>
</figure>
</div>
<p>차이점은 Wold’s theorem 이 성립하기 위해서 <span class="math inline">\(\lambda_i \neq \lambda_j, \forall i\neq j\)</span> 조건이 추가된다는 것이다.</p>
</section>
<section id="psd" class="level1">
<h1>12.2.1. PSD</h1>
<p><code>-</code> Stationarity reduces the degrees of freedom of a random graph process, thus facilitating its description and understanding. It follows from <strong>Definition 12.2b</strong> that one can express the remaining degrees of freedom in the frequency domain via the notion of PSD, as defined next.</p>
<p><strong>Definition 12.3.</strong> The PSD of a random process <span class="math inline">\(\mathbf{x}\)</span> that is stationary with respect to <span class="math inline">\(\mathbf{S} = \mathbf{V} \mathbf{\Lambda} \mathbf{V}^H\)</span> is the nonnegative <span class="math inline">\(N \times 1\)</span> vector <span class="math inline">\(\mathbf{p}\)</span></p>
<p><span class="math display">\[
\mathbf{p} := \text{diag} \left( \mathbf{V}^H \mathbf{C}_{\mathbf{x}} \mathbf{V} \right).
\]</span></p>
<p>Observe that because <span class="math inline">\(\mathbf{C}_{\mathbf{x}}\)</span> is diagonalized by <span class="math inline">\(\mathbf{V}\)</span> (see ) the matrix <span class="math inline">\(\mathbf{V}^H \mathbf{C}_{\mathbf{x}} \mathbf{V}\)</span> is diagonal and it follows that the PSD in Eq. (12.4) corresponds to the eigenvalues of the positive semidefinite covariance matrix <span class="math inline">\(\mathbf{C}_{\mathbf{x}}\)</span>. Thus, Eq. (12.4) is equivalent to</p>
<p><span class="math display">\[
\mathbf{C}_{\mathbf{x}} = \mathbf{V} \text{diag}(\mathbf{p}) \mathbf{V}^H.
\]</span></p>
<p><code>*</code> 식 <span class="math inline">\(\mathbf{C}_{\mathbf{x}} = \mathbf{V} \text{diag}(\mathbf{p}) \mathbf{V}^H\)</span>가 성립하는 이유는 다음과 같다.</p>
<p>먼저, 자기상관 행렬 <span class="math inline">\(\mathbf{C}_{\mathbf{x}}\)</span>는 주어진 랜덤 프로세스 <span class="math inline">\(\mathbf{x}\)</span>의 공분산 행렬로, 이는 양의 준정부호(positive semidefinite) 행렬이다. 이 행렬은 대각화할 수 있으며, 문제에서 주어진 <span class="math inline">\(\mathbf{S} = \mathbf{V} \mathbf{\Lambda} \mathbf{V}^H\)</span>와 마찬가지로 <span class="math inline">\(\mathbf{V}\)</span>에 의해 대각화된다. 따라서 <span class="math inline">\(\mathbf{C}_{\mathbf{x}}\)</span>는 다음과 같이 표현할 수 있다:</p>
<p><span class="math display">\[
\mathbf{C}_{\mathbf{x}} = \mathbf{V} \mathbf{\Lambda}_C \mathbf{V}^H
\]</span></p>
<p>여기서 <span class="math inline">\(\mathbf{\Lambda}_C\)</span>는 <span class="math inline">\(\mathbf{C}_{\mathbf{x}}\)</span>의 고유값들을 가지는 대각 행렬이다.</p>
<p>파워 스펙트럼 밀도(PSD)의 정의에 따르면, <span class="math inline">\(\mathbf{p} = \text{diag}(\mathbf{V}^H \mathbf{C}_{\mathbf{x}} \mathbf{V})\)</span>는 자기상관 행렬 <span class="math inline">\(\mathbf{C}_{\mathbf{x}}\)</span>의 대각 성분들, 즉 고유값들을 모은 벡터이다. 따라서 <span class="math inline">\(\mathbf{\Lambda}_C\)</span>는 <span class="math inline">\(\text{diag}(\mathbf{p})\)</span>로 표현될 수 있다.</p>
<p>이를 종합하면, <span class="math inline">\(\mathbf{C}_{\mathbf{x}}\)</span>는 <span class="math inline">\(\mathbf{V}\)</span>와 <span class="math inline">\(\mathbf{\Lambda}_C = \text{diag}(\mathbf{p})\)</span>에 의해 대각화될 수 있으며, 따라서 <span class="math inline">\(\mathbf{C}_{\mathbf{x}}\)</span>는 다음과 같이 쓸 수 있다:</p>
<p><span class="math display">\[
\mathbf{C}_{\mathbf{x}} = \mathbf{V} \text{diag}(\mathbf{p}) \mathbf{V}^H
\]</span></p>
<p>이것이 식 <span class="math inline">\(\mathbf{C}_{\mathbf{x}} = \mathbf{V} \text{diag}(\mathbf{p}) \mathbf{V}^H\)</span>가 성립하는 이유다. <span class="math inline">\(\mathbf{C}_{\mathbf{x}}\)</span>는 <span class="math inline">\(\mathbf{V}\)</span>에 의해 대각화될 수 있으며, 이때의 고유값들이 <span class="math inline">\(\mathbf{p}\)</span>로 표현되기 때문이다.</p>
<p><code>-</code> Zero-mean white noise is an example of a random process that is stationary with respect to any graph shift <span class="math inline">\(\mathbf{S}\)</span>. The PSD of white noise with covariance <span class="math inline">\(\mathbb{E}[\mathbf{nn}^H] = \sigma^2 \mathbf{I}\)</span> is <span class="math inline">\(\mathbf{p} = \sigma^2 \mathbf{1}\)</span>. Also notice that, by definition, any random process <span class="math inline">\(\mathbf{x}\)</span> is stationary with respect to the shift <span class="math inline">\(\mathbf{S} = \mathbf{C}_{\mathbf{x}}\)</span> defined by its covariance matrix, with corresponding PSD <span class="math inline">\(\mathbf{p} = \text{diag}(\mathbf{\Lambda})\)</span>. This can be exploited in the context of network topology inference. Given a set of graph signals <span class="math inline">\(\{\mathbf{x}_r\}_{r=1}^R\)</span>, it is common to infer the underlying topology by building a graph <span class="math inline">\(\mathbf{G}_{\text{corr}}\)</span> whose edge weights correspond to cross-correlations among the entries of the signals. In that case, the process generating those signals is stationary in the shift given by the adjacency of <span class="math inline">\(\mathbf{G}_{\text{corr}}\)</span>; see [23] for details. A random process <span class="math inline">\(\mathbf{x}\)</span> is also stationary with respect to the shift given by its precision matrix, which is defined as the (pseudo-)inverse <span class="math inline">\(\Theta = \mathbf{C}_{\mathbf{x}}^{\dagger}\)</span>. The PSD, in this case, is <span class="math inline">\(\mathbf{p} = \text{diag}(\mathbf{\Lambda})^{\dagger}\)</span>. This is particularly important when <span class="math inline">\(\mathbf{x}\)</span> is a Gaussian Markov Random Field (GMRF) whose Markovian dependence is captured by the unweighted graph <span class="math inline">\(\mathbf{G}_{\text{MRF}}\)</span>. It is well known [24, Ch. 19] that in these cases <span class="math inline">\(\Theta_{ij}\)</span> can be nonzero only if <span class="math inline">\((i,j)\)</span> is either a link of <span class="math inline">\(\mathbf{G}_{\text{MRF}}\)</span>, or an element in the diagonal. Thus, any GMRF is stationary with respect to the shift <span class="math inline">\(\mathbf{S} = \mathbf{\Theta}\)</span>, which captures the conditional dependence between the elements of <span class="math inline">\(\mathbf{x}\)</span>.</p>
<p><code>*</code> <strong>백색 잡음(Zero-mean white noise)</strong>은 어떤 그래프 시프트 연산자 <span class="math inline">\(\mathbf{S}\)</span>에 대해서도 정상적인(stationary) 랜덤 프로세스의 예시이다. 백색 잡음의 공분산이 <span class="math inline">\(\mathbb{E}[\mathbf{nn}^H] = \sigma^2 \mathbf{I}\)</span>로 주어질 때, 이 백색 잡음의 PSD는 <span class="math inline">\(\mathbf{p} = \sigma^2 \mathbf{1}\)</span>로 표현된다. 여기서 <span class="math inline">\(\mathbf{1}\)</span>은 모든 원소가 1인 벡터를 의미한다. 랜덤 프로세스 <span class="math inline">\(\mathbf{x}\)</span>는 공분산 행렬 <span class="math inline">\(\mathbf{C}_{\mathbf{x}}\)</span>로 정의된 시프트 연산자 <span class="math inline">\(\mathbf{S} = \mathbf{C}_{\mathbf{x}}\)</span>에 대해 항상 정상적이다. 이 경우에 해당하는 PSD는 <span class="math inline">\(\mathbf{p} = \text{diag}(\mathbf{\Lambda})\)</span>로 나타낼 수 있다. 이 특성은 네트워크 토폴로지 추론과 같은 응용 분야에서 활용될 수 있다. 여러 그래프 신호들 <span class="math inline">\({\mathbf{x}_r}_{r=1}^R\)</span>이 주어졌을 때, 이러한 신호들의 교차 상관 관계를 반영하여 그래프 <span class="math inline">\(\mathbf{G}_{\text{corr}}\)</span>을 구축함으로써 기본적인 토폴로지를 추론하는 것이 일반적이다. 이 경우, 이러한 신호들을 생성하는 프로세스는 <span class="math inline">\(\mathbf{G}_{\text{corr}}\)</span>의 인접 행렬에 의해 주어지는 시프트 연산자에 대해 정상적이다. 랜덤 프로세스 <span class="math inline">\(\mathbf{x}\)</span>는 그 공분산 행렬의 (유사)역행렬(pseudo-inverse)로 정의되는 정밀 행렬(precision matrix)에 의해 주어지는 시프트 연산자에 대해서도 정상적이다. 이 경우의 PSD는 <span class="math inline">\(\mathbf{p} = \text{diag}(\mathbf{\Lambda})^{\dagger}\)</span>로 표현된다. 여기서 <span class="math inline">\(\dagger\)</span>는 유사역행렬을 의미한다. 이 개념은 특히 <span class="math inline">\(\mathbf{x}\)</span>가 <strong>가우시안 마르코프 랜덤 필드(GMRF)</strong>일 때 중요하다. GMRF의 마르코프 의존성은 가중치가 없는(unweighted) 그래프 <span class="math inline">\(\mathbf{G}_{\text{MRF}}\)</span>에 의해 포착된다. 잘 알려진 바에 따르면, 이러한 경우 <span class="math inline">\(\Theta_{ij}\)</span>는 <span class="math inline">\((i,j)\)</span>가 <span class="math inline">\(\mathbf{G}_{\text{MRF}}\)</span>의 링크이거나 대각선 원소일 때만 0이 아닐 수 있다. 따라서, 어떤 GMRF도 <span class="math inline">\(\mathbf{x}\)</span>의 원소들 간의 조건부 독립성을 포착하는 희소 시프트 연산자 <span class="math inline">\(\mathbf{S} = \mathbf{\Theta}\)</span>에 대해 정상적이다.</p>
<p><code>**</code> 랜덤 프로세스 <span class="math inline">\(\mathbf{x}\)</span>는 그 공분산 행렬의 (유사)역행렬로 정의되는 정밀 행렬(precision matrix)에 의해 주어지는 시프트 연산자에 대해서도 정상적이다. 이 경우의 PSD는 <span class="math inline">\(\mathbf{p} = \text{diag}(\mathbf{\Lambda})^{\dagger}\)</span>로 표현된다. 여기서 <span class="math inline">\(\dagger\)</span>는 유사역행렬을 의미한다. 이 개념은 특히 <span class="math inline">\(\mathbf{x}\)</span>가 가우시안 마르코프 랜덤 필드(GMRF)일 때 중요하다. GMRF의 마르코프 의존성은 가중치가 없는(unweighted) 그래프 <span class="math inline">\(\mathbf{G}_{\text{MRF}}\)</span>에 의해 포착된다. 잘 알려진 바에 따르면, 이러한 경우 $_{ij} $는 <span class="math inline">\((i,j)\)</span>가 <span class="math inline">\(\mathbf{G}_{\text{MRF}}\)</span>의 링크이거나 대각선 원소일 때만 0이 아닐 수 있다. 따라서, 어떤 GMRF도 <span class="math inline">\(\mathbf{x}\)</span>의 원소들 간의 조건부 독립성을 포착하는 희소 시프트 연산자 <span class="math inline">\(\mathbf{S} = \mathbf{\Theta}\)</span>에 대해 정상적이다.</p>
<p>이를 좀 더 자세히 설명하면, 정밀 행렬은 공분산 행렬의 역행렬로, 변수 간의 조건부 독립성을 나타낸다. 만약 어떤 변수 <span class="math inline">\(\mathbf{x}_i\)</span>와 <span class="math inline">\(\mathbf{x}_j\)</span>가 다른 변수들이 주어진 상태에서 독립이라면, 정밀 행렬의 해당 위치 <span class="math inline">\(\Theta_{ij}\)</span>는 0이 된다. 일반적으로 공분산 행렬이 정확히 가역(invertible)하지 않을 수 있으므로, 유사역행렬(pseudo-inverse)을 사용하여 정밀 행렬을 계산할 수 있다. 가우시안 마르코프 랜덤 필드(GMRF)는 가우시안 분포를 따르는 변수들이 마르코프 속성을 갖는 랜덤 필드이다. 마르코프 속성은 변수 <span class="math inline">\(\mathbf{x}_i\)</span>가 다른 변수 <span class="math inline">\(\mathbf{x}_j\)</span>와의 관계에서 특정 변수들만을 통해 영향을 받는다는 것을 의미한다. 이 관계는 그래프의 형태로 표현할 수 있는데, 그래프의 각 노드는 변수에 해당하고, 그래프의 엣지는 변수 간의 조건부 의존성을 나타낸다.</p>
<p>예를 들어, 세 개의 변수 <span class="math inline">\(\mathbf{x}_1\)</span>, <span class="math inline">\(\mathbf{x}_2\)</span>, <span class="math inline">\(\mathbf{x}_3\)</span>이 있다고 가정할 때, 이 변수들이 GMRF를 이루며 <span class="math inline">\(\mathbf{x}_1\)</span>과 <span class="math inline">\(\mathbf{x}_2\)</span>가 직접적으로 연결되고, <span class="math inline">\(\mathbf{x}_2\)</span>와 <span class="math inline">\(\mathbf{x}_3\)</span>도 직접적으로 연결되어 있지만, <span class="math inline">\(\mathbf{x}_1\)</span>과 <span class="math inline">\(\mathbf{x}_3\)</span>는 <span class="math inline">\(\mathbf{x}_2\)</span>를 통해서만 상호작용한다고 하자. 이 경우, 정밀 행렬 <span class="math inline">\(\mathbf{\Theta}\)</span>는 다음과 같은 형태를 가질 수 있다:</p>
<p><span class="math display">\[
\mathbf{\Theta} =
\begin{pmatrix}
\Theta_{11} &amp; \Theta_{12} &amp; 0 \\
\Theta_{12} &amp; \Theta_{22} &amp; \Theta_{23} \\
0 &amp; \Theta_{23} &amp; \Theta_{33}
\end{pmatrix}
\]</span></p>
<p>여기서 <span class="math inline">\(\Theta_{13} = 0\)</span>임을 알 수 있다. 이는 <span class="math inline">\(\mathbf{x}_1\)</span>과 <span class="math inline">\(\mathbf{x}_3\)</span>가 조건부 독립임을 나타내며, <span class="math inline">\(\mathbf{x}_2\)</span>를 통해서만 상호작용함을 의미한다. 이러한 정밀 행렬을 시프트 연산자로 사용하면, GMRF는 이러한 시프트에 대해 정상적인 랜덤 프로세스가 된다. 이 경우의 파워 스펙트럼 밀도(PSD)는 <span class="math inline">\(\mathbf{p} = \text{diag}(\mathbf{\Lambda})^{\dagger}\)</span>로 표현된다. 여기서 <span class="math inline">\(\mathbf{\Lambda}\)</span>는 정밀 행렬의 고유값이고, <span class="math inline">\(\dagger\)</span>는 유사역행렬을 의미한다. GMRF의 경우, 정밀 행렬을 시프트 연산자로 사용하면 변수들 간의 조건부 독립성을 효과적으로 표현할 수 있으며, 이러한 관계에 대해 정상적이라는 특성을 갖게 된다. 이는 네트워크나 그래프 구조에서 변수들 간의 관계를 분석하는 데 중요한 개념이다.</p>
<p><code>**</code> 가우시안 마르코프 랜덤 필드(GMRF)의 예시와 GMRF가 아닌 예시를 소개하겠다.</p>
<p><strong>[GMRF의 예시]</strong></p>
<p><strong>1. 2D 격자 그래프 모델</strong></p>
<p>가장 일반적인 GMRF 예시는 2차원 격자 그래프 모델이다. 이 모델은 이미지 처리와 같은 분야에서 자주 사용된다. 각 노드는 이미지의 픽셀에 해당하며, 각 노드는 그 주변에 있는 네 개의 이웃 노드(위, 아래, 왼쪽, 오른쪽)와만 연결된다. 이 연결은 각 픽셀이 인접한 픽셀들과만 상호작용하고, 더 멀리 떨어진 픽셀들과는 직접적인 상호작용이 없다는 것을 나타낸다. 따라서 이러한 구조는 GMRF의 조건부 독립성 조건을 만족한다.</p>
<p>예를 들어, 픽셀 <span class="math inline">\(x_{i,j}\)</span>는 픽셀 <span class="math inline">\(x_{i-1,j}\)</span>, <span class="math inline">\(x_{i+1,j}\)</span>, <span class="math inline">\(x_{i,j-1}\)</span>, <span class="math inline">\(x_{i,j+1}\)</span>와는 상호작용하지만, 직접적으로 연결되지 않은 다른 모든 픽셀과는 독립이다. 이를 수식으로 나타내면 다음과 같다:</p>
<p><span class="math display">\[
P(x_{i,j} \mid \text{other pixels}) = P(x_{i,j} \mid x_{i-1,j}, x_{i+1,j}, x_{i,j-1}, x_{i,j+1})
\]</span></p>
<p><strong>2. 트리 그래프 모델</strong></p>
<p>또 다른 GMRF의 예시는 트리 구조를 가진 그래프이다. 트리 그래프에서는 각 노드가 부모 노드와 자식 노드로 연결되어 있으며, 형제 노드끼리는 직접적인 연결이 없다. 이러한 구조 역시 조건부 독립성 조건을 만족한다. 예를 들어, 노드 <span class="math inline">\(x_i\)</span>는 부모 노드 <span class="math inline">\(x_{parent}\)</span>와 자식 노드 <span class="math inline">\(x_{child1}\)</span>, <span class="math inline">\(x_{child2}\)</span> 등과 상호작용하지만, 형제 노드들 <span class="math inline">\(x_{sibling1}\)</span>, <span class="math inline">\(x_{sibling2}\)</span> 등과는 부모 노드를 통해서만 상호작용한다.</p>
<p><strong>[GMRF가 아닌 예시]</strong></p>
<p><strong>1. 완전 연결 그래프 (Fully Connected Graph)</strong></p>
<p>완전 연결 그래프는 모든 노드가 서로 직접 연결된 그래프이다. 이 경우, 모든 노드가 다른 모든 노드와 상호작용하므로, 조건부 독립성이 성립하지 않는다. 따라서 완전 연결 그래프는 GMRF가 아니다. 예를 들어, 세 개의 노드 <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\)</span>, <span class="math inline">\(x_3\)</span>가 있을 때, <span class="math inline">\(x_1\)</span>과 <span class="math inline">\(x_2\)</span>, <span class="math inline">\(x_1\)</span>과 <span class="math inline">\(x_3\)</span>, 그리고 <span class="math inline">\(x_2\)</span>와 <span class="math inline">\(x_3\)</span> 모두가 직접적으로 연결되어 있다면, <span class="math inline">\(x_1\)</span>이 주어졌을 때 <span class="math inline">\(x_2\)</span>와 <span class="math inline">\(x_3\)</span>이 독립이라는 조건이 성립하지 않는다.</p>
<p><strong>2. 순환 그래프 (Cyclic Graph)</strong></p>
<p>순환 그래프(cyclic graph)는 각 노드가 서로 순환적으로 연결된 구조를 가지며, 이 경우에도 GMRF가 아닐 수 있다. 예를 들어, 세 개의 노드 <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\)</span>, <span class="math inline">\(x_3\)</span>가 있고, <span class="math inline">\(x_1\)</span>이 <span class="math inline">\(x_2\)</span>와 <span class="math inline">\(x_3\)</span>에 연결되어 있으며, <span class="math inline">\(x_2\)</span>와 <span class="math inline">\(x_3\)</span>도 서로 연결되어 있다고 하자. 이 경우, <span class="math inline">\(x_1\)</span>이 주어졌을 때도 <span class="math inline">\(x_2\)</span>와 <span class="math inline">\(x_3\)</span> 간의 상호작용이 여전히 남아 있을 수 있으므로, 조건부 독립성이 성립하지 않아 GMRF가 되지 않는다.</p>
<p>이러한 예시들을 통해 GMRF와 GMRF가 아닌 구조를 구분할 수 있다. GMRF의 핵심은 특정 노드가 다른 노드들과 어떻게 조건부 독립성을 가지는지에 있으며, 이 조건부 독립성은 그래프의 구조에 의해 결정된다.</p>



</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="miruetoto/yechan3" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>